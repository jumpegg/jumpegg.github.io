{"meta":{"title":"Wonny's note","subtitle":null,"description":null,"author":"Wonny","url":"https://jumpegg.github.io"},"pages":[],"posts":[{"title":"angular2-problem-01","slug":"angular2-problem-01","date":"2017-07-20T05:34:59.000Z","updated":"2017-07-20T05:44:10.809Z","comments":true,"path":"2017/07/20/angular2-problem-01/","link":"","permalink":"https://jumpegg.github.io/2017/07/20/angular2-problem-01/","excerpt":"","text":"nginx 파일업로드 제한 문제Angular로 개인 프로젝트로 만든 사이트중 파일 업로드 부분에서 문제가 발생했었다. 문제인식부끄럽게도 면접보러 간 자리에서 파일 업로드에 문제가 발생한것을 발견했다. 그 당시에 확인한 오류 메세지와 혼자 고치면서 보게된 메세지가 달라서 이후에 다른 문제점을 발견할 수도 있는데 일단 지금 확인된 버그부터 수정했다. 원인내가받은 에러메세지는 ‘413 Request Entity Too Large’ 였다. nginx에서 파일업로드 설정이 없으면 용량에 제한이 걸리는듯 했다. 필자는 서버구현 부분에서 용량제한을 걸어놨었고 nginx에는 따로 설정을 하지 않아서 생기는 문제로 인식되었다. 해결nginx의 설정파일에 최대 body사이즈를 설정해준다. nginx가 존재하는 곳을 찾기위해 ‘whereis nginx’ 명령어를 사용했다. 1$ whereis nginx 그리고 vi로 default.conf 파일을 열어 다음 설정을 추가해주었다. 1client_max_body_size 20M; 출처참조 블로그","categories":[{"name":"문제해결","slug":"문제해결","permalink":"https://jumpegg.github.io/categories/문제해결/"}],"tags":[{"name":"nginx 파일업로드","slug":"nginx-파일업로드","permalink":"https://jumpegg.github.io/tags/nginx-파일업로드/"}]},{"title":"Javascript 패턴 - 객체 생성 패턴 2","slug":"pattern-object2","date":"2017-07-18T09:26:22.000Z","updated":"2017-07-18T09:36:30.640Z","comments":true,"path":"2017/07/18/pattern-object2/","link":"","permalink":"https://jumpegg.github.io/2017/07/18/pattern-object2/","excerpt":"","text":"5.3 비공개 프로퍼티와 메서드자바 등 다른 언어와는 달리 자바스크립트에는 private, protected, public 프로퍼티와 메서드를 나타내는 별도의 문법이 없다. 객체의 모든 멤버는 public, 즉 공개되어 있다. 12345678var myobj = &#123; myprop: 1, getProp: function() &#123; return this.myprop; &#125;&#125;console.log(myobj.myprop); // 'myprop'에 공개적으로 접근할 수 있다.console.log(myobj.getProp()); // getProp() 역시 공개되어 있다. 비공개(private) 멤버비공개 멤버에 대한 별도의 문법은 없지만 클로저를 사용해서 구현할 수 있다. 생성자 함수 안에서 클로저를 만들면, 클로저 유효범위 안의 변수는 생성자 함수 외부에 노출되지 않지만 객체의 공개 메서드 안에서는 쓸 수 있다. 123456789101112131415function Gadget()&#123; // 비공개 멤버 var name = 'iPod'; // 공개된 함수 this.getName = function() &#123; return name; &#125;;&#125;var toy = new Gadget();// 'name'은 비공개이므로 undefined가 출력된다.console.log(toy.name); // undefined// 공개 메서드에서는 'name'에 접근할 수 있다.console.log(toy.getName()); 특권 메서드특권 메서드는 비공개 멤버를 외부에서 접근 가능하게 하는 메서드를 말한다. 위에서는 getName()에 해당한다. 비공개 멤버의 허점비공개 멤버를 유지하는게 관건이라면, 다음과 같은 경우에 대해서 신경을 써야 한다. 파이어폭스의 초기 버전 중 일부는 eval() 함수에 두 번째 매개변수를 전달 할 수 있게 되어있다. 이 매개변수는 함수의 비공개 유효범위를 들여다볼 수 있게 해주는 컨텍스트 객체다. 모질라 라이노(Rhino)의 parent 프로퍼티도 이와 비슷한 방식으로 비공개 유효범위에 접근할 수 있게 해준다. 현재 널리 사용되는 브라우저에는 적용되지 않는 사례들이다. 특권 메서드에서 비공개 변수의 값을 바로 반환할 경우 이 변수가 객체나 배열이라면 값이 아닌 참조가 반환되기 때문에, 외부 코드에서 비공개 변수값을 수정할 수 있다. 비공개 멤버에 대한 접근123456789101112function Gadget()&#123; // 비공개 멤버 var specs = &#123; screen_width: 320, screen_height: 480, color: \"white\" &#125;; // 공개 함수 this.getSpecs = function()&#123; return specs; &#125;&#125; 여기서 getSpec() 메서드가 specs 객체에 대한 참조를 반환하는게 문제다. 의도적으로 감춘 specs를 참조를 통해 외부에서 변경이 가능해지게 된 것이다. 의도대로라면 setSpec()메서드를 통해서만 값을 변경 가능하게 작동해야 한다. 이를 해결하기 위해서는 getSpec() 에 객체를 복사해서 반환하는 방식으로 구현을 하면 된다. 이를 ‘최소 권한의 원칙(Principle of Least Authority, POLA)’ 이라고도 한다. 객체 리터럴과 비공개 멤버지금까지는 비공개 멤버를 만드는데 생성자를 사용했다. 그렇다면 객체 리터럴로 만들어진 객체는 비공개 멤버를 구현할 수 있을까? 객체 리터럴에서는 익명 즉시 실행함수 를 추가하여 클로저를 만든다. 다음 예제를 보자. 123456789101112131415var myobj;(function()&#123; // 비공개 멤버 var name = \"my, oh my\"; // 공개될 부분을 구현한다. // var를 사용하지 않았다는데 주의하라. myobj = &#123; // 특권 메서드 getName: function()&#123; return name; &#125; &#125;;&#125;());myobj.getName(); // \"my, oh my\" 다음 예제는 기본 개념은 동일하지만 약간 다르게 구현되어 있다. 앞으로 나올 ‘모듈 패턴’의 기초가 되는 예제이다. 12345678910111213var myobj = (function()&#123; // 비공개 멤버 var name = \"my, oh my\"; // 공개될 부분을 구현한다. return &#123; getName: function()&#123; return name; &#125; &#125;;&#125;());myobj.getName(); // \"my, oh my\" 프로토타입과 비공개 멤버생성자를 사용하여 비공개 멤버를 만들 경우, 생성자를 호출하여 새로운 객체를 만들 때마다 비공개 멤버가 매번 재생성된다는 단점이 있다.","categories":[{"name":"Javascript Pattern","slug":"Javascript-Pattern","permalink":"https://jumpegg.github.io/categories/Javascript-Pattern/"}],"tags":[{"name":"pattern","slug":"pattern","permalink":"https://jumpegg.github.io/tags/pattern/"}]},{"title":"Javascript 패턴 - 객체 생성 패턴 1","slug":"pattern-object1","date":"2017-07-18T07:48:25.000Z","updated":"2017-07-18T09:27:13.070Z","comments":true,"path":"2017/07/18/pattern-object1/","link":"","permalink":"https://jumpegg.github.io/2017/07/18/pattern-object1/","excerpt":"","text":"5.1 네임스페이스 패턴네임스페이스 패턴네임스페이스는 프로그램에서 필요로 하는 전역 변수의 개수를 줄이는 동시에 과도한 접두어를 사용하지 않고도 이름이 겹치지 않게 해준다. 이러한 네임스페이스 패턴은 자바스크립트 언어에 내장된 기능은 아니지만 어렵지 않게 구현할 수 있다. 1234567891011121314151617// 전역 객체var myApp = &#123;&#125;;// 생성자myApp.parent = function() &#123;&#125;;myApp.child = function() &#123;&#125;;// 변수myApp.some_var = 1;// 객체 컨테이너myApp.modules = &#123;&#125;;// 객체들을 컨테이너 안에 추가한다.myApp.modules.module1 = &#123;&#125;;myApp.modules.module1.data = &#123;a : 1, b : 2&#125;;myApp.modules.module2 = &#123;&#125;; 먼저 애플리케이션 전역 전용 객체 (위에선 myApp이 전역 전용 객체)를 생성한다. 그런 다음 모든 함수와 변수들을 이 전역 객체의 프로퍼티로 생성한다. 이 패턴은 코드에 네임스페이스를 지정해주며, 코드 내의 이름 충돌 뿐 아니라 이 코드와 같은 페이지에 존재하는 자바스크립트 라이브러리나 위젯 등 서드 파티 코드와의 이름 충돌도 방지해준다. 단점 모든 변수와 함수에 접두어를 붙여야 하기 때문에 전체적으로 코드량이 약간 더 많아지고 따라서 다운로드해야 하는 파일 크기도 늘어난다. 전역 인스턴스가 단 하나뿐이기 때문에 코드의 어느 한 부분이 수정되어도 전역 인스턴스를 수정하게 된다. 즉 나머지 기능들도 갱신된 상태를 물려받는다. 이름이 중첩되고 길어지므로 프로퍼티를 판별하기 위한 검색 작업도 길고 느려진다. 이 장의 뒷부분에서는 이 단점을 해결하기 위한 방법으로는 샌드박스 패턴이 있다. 범용 네임스페이스 함수프로그램의 복잡도가 증가하고 코드의 각 부분들이 별개의 파일로 분리되어 선택적으로 문서에 포함되게 되면, 어떤 코드가 특정 네임스페이스나 그 내부의 프로퍼티를 처음으로 정의한다고 가정하기가 위험하다. 그러므로 네임스페이스를 생성하거나 프로퍼티를 추가하기 전에 먼저 이미 존재하는지 여부를 확인하는 것이 최선이다. 123456// 생성 이전에 존재여부 확인if( typeof myApp === \"undefined\")&#123; var myApp = &#123;&#125;;&#125;// 간략히 줄임var myApp = myApp || &#123;&#125;; 이런 확인작업의 추가는 상당량의 중복 코드를 발생시키므로 네임스페이스를 생성하는 재사용 가능한 함수를 만들어 두는편이 편하다. 12345678910111213141516171819var myApp = myApp || &#123;&#125;;myApp.namespace = function(ns_string)&#123; var parts = ns_string.split('.'), var parent = myApp, var i; if (parts[0] === \"myApp\")&#123; parts = parts.slice(1); &#125; for(i=0; i&lt;parts.length; i+=1)&#123; if(typeof parent[parts[i]] === \"undefined\")&#123; parent[parts[i]] = &#123;&#125;; &#125; parent = parent[parts[i]]; &#125; return parent;&#125;; 이 코드는 다음 모든 예에서 사용할 수 있다.123456789// 반환 값을 지역변수에 할당한다.var module2 = myApp.namespace('myApp.modules.module2');module2 === myApp.modules.module2; // true// 첫 부분의 'myApp'을 생략하고도 쓸 수 있다.myApp.namespace('modules.module51');// 아주 긴 네임스페이스myApp.namespace('once.upon.a.time.there.was.this.long.nested.property'); 5.2 의존 관계 선언자바스크립트 라이브러리들은 대개 네임스페이스를 지정하여 모듈화되어 있기 때문에, 필요한 모듈만 골라서 쓸 수 있다. 예를 들어 YUI2에는 네임스페이스 역할을 하는 YAHOO 라는 전역변수가 있다. 이때 함수나 모듈 내 최상단에, 의존 관계에 있는 모듈을 선언하는 것이 좋다. 즉 지역변수를 만들어 원하는 모듈을 가리키도록 선언하는 것이다. 1234567var myFunction = function() &#123; // 의존관계에 있는 모듈들 var event = YAHOO.util.Event, var dom = YAHOO.util.Dom; // 이제 event와 dom 이라는 변수를 사용한다....&#125; 대단히 간단한 패턴이지만 상당히 많은 장점을 가지고 있다. 의존 관계가 명시적으로 선언되어 있기 때문에 코드를 사용하는 사람이 페이지내에 반드시 포함시켜야 하는 스크립트 파일이 무엇인지 알 수 있다. 함수의 첫머리에 의존 관계가 선언되기 때문에 의존 관계를 찾아내고 이해하기가 쉽다. dom과 같은 지역 변수는 YAHOO와 같은 전역 변수보다 언제나 더 빠르며 YAHOO.util.Dom 처럼 전역 변수의 중첩 프로퍼티와 비교하면 더 말할 것도 없다. 의존 관계 선언 패턴을 잘 지키면 함수 안에서 전역 객체 판별을 단 한번만 수행하고, 이 다음부터는 지역 변수를 사용하기 때문에 훨씬 빠르다. YUI 컴프레서나 구글 클로저 등 고급 압축 도구는 지역 변수명에 대해서는 event를 A 라는 글자 하나로 바꾸는 식으로 축약해 코드를 줄여준다. 하지만 전역 변수명 변경은 위험하기 때문에 축약하지 않는다.","categories":[{"name":"Javascript Pattern","slug":"Javascript-Pattern","permalink":"https://jumpegg.github.io/categories/Javascript-Pattern/"}],"tags":[{"name":"pattern","slug":"pattern","permalink":"https://jumpegg.github.io/tags/pattern/"}]},{"title":"CH 4 트랜잭션(4.4, 4.5)","slug":"mysql-transection3","date":"2017-07-15T01:29:33.000Z","updated":"2017-07-15T04:25:45.876Z","comments":true,"path":"2017/07/15/mysql-transection3/","link":"","permalink":"https://jumpegg.github.io/2017/07/15/mysql-transection3/","excerpt":"","text":"4.4 InnoDB 스토리지 엔진의 잠금InnoDb 스토리지 엔진은 MYSQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다. 4.4.1 InnoDB의 잠금 방식 비관적 잠금현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식 낙관적 잠금 낙관적 잠금에서는 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고 가정한다. 그래서 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK처리 하는 방식을 의미한다. 4.4.2 InnoDB의 잠금의 종류 레코드 락(Record lock, Record only lock) 레코드 자체만을 잠그는 것을 레코드 락 이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다. 만약 인덱스가 하나도 없는 테이블이라 하더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다. 갭 락(Gap lock) 다른 DBMS와의 또 다른 차이는 바로 갭 락이다. 갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 것이다. 넥스트 키 락(Next key lock) 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다. 자동 증가 락(Auto increment lock) Auto_increment 칼럼이 사용된 테이블에 동시에 여러 레코드가 insert 되는 경우, 저장되는 각 레고드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다. InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 Auto_increment 락이라고 하는 테이블의 수준의 잠금을 사용한다. 4.4.3 인덱스와 잠금InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있다. 레코드 락은 레코드의 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다. 하나의 테이블에 update 문장이 실행되면 Mysql의 InnoDB는 인덱스로 사용된 컬럼의 값과 동일한 레코드 들에 락을 건다. 만약 인덱스가 없다면 해당 테이블의 레코드에 모두 락을 건다. 4.4.4 트랜잭션 격리 수준과 잠금이러한 불필요한 레코드의 잠금 현상은 InnoDB의 넥스트 키 락 때문에 발생하는 것이다. 하지만 InnoDB에서 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문이다. 레코드 기반의 바이너리 로그를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다. Mysql 5.0innodb_locks_unsafe_for_binlog = 1트랜잭션 격리수준을 READ-COMMIT 로 설정 Mysql 5.1 이상 바이너리 로그를 비활성화 레코드 기반의 바이너리 로그 사용 : innodb_locks_unsafe_for_binlog = 1 4.4.5 레코드 수준의 잠금 확인 및 해제InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 복잡하다.(복잡해서 요약이 안됨) 4.5 Mysql의 격리 수준트랜잭션의 격리 수준이란 동시에 여러 트랜잭션이 처리될 때, 득정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 격리 수준은 크게 READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALIZABLE 의 4가지로 나뉜다. 데이터베이스의 격리수준을 이야기 하면 항상 언급되는 것은 부정합이다. 3가지 부정합 문제가 있으며 각각의 격리수준에 따른 부정합 문제는 다음과 같다. 격리수준 DIRTY READ NON-REPEATABLE READ PHANTOM READ READ UNCOMMITTED 발생 발생 발생 READ COMMITTED 발생하지 않음 발생 발생 REPEATABLE READ 발생하지 않음 발생하지 않음 발생(InnoDB는 발생하지 않음) SERIALIZABLE 발생하지 않음 발생하지 않음 발생하지 않음 4.5.1 READ UNCOMMITTEDREAD UNCOMMITTED 격리 수준에서는 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다. 이때 다른 트랜잭션에는 변경된 레코드가 반영되지 않는 현상을 Dirty read 라고 한다. Dirty read는 사용자와 개발자를 혼란스럽게 한다. 4.5.2 READ COMMITTEDREAD COMMITTED는 오라클 DBMS에서 기본적으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. Dirty read 같은 현상은 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 Commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다. READ COMMITTED는 Non-repeatable read 부정합의 문제가 있다. 데이터 변경 후 커밋 이전에 조회문을 날렸을 때와 커밋 이후에 조회문을 날렸을 때 가져오는 데이터가 다른 경우, 하나의 트랜잭션에서 똑같은 select 쿼리를 실행했을 때 항상 같은 결과를 가져와야 하는데 위의 경우는 다른 결과를 가져오게 된다. 이러한 부정합 현상은 일반적인 웹에서는 문제는 없지만 하나의 트랜잭션에서 데이터를 여러번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다. 4.5.3 REPEATABLE READREPEATABLE READ는 Mysql의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다. 바이너리 로그를 가진 Mysql의 장비에서는 최소 Repeatable read 격리 수준 이상을 사용해야 한다. InnoDB에서는 MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다. 4.5.4. SERIALIZABLE가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다. 또한 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. 트랜잭션의 격리수준이 SERIALIZABLE 로 설정되면 일기 작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"transection","slug":"transection","permalink":"https://jumpegg.github.io/tags/transection/"}]},{"title":"ionic root nav 문제해결","slug":"ionic-problem-01","date":"2017-07-13T09:09:16.000Z","updated":"2017-07-13T09:39:25.897Z","comments":true,"path":"2017/07/13/ionic-problem-01/","link":"","permalink":"https://jumpegg.github.io/2017/07/13/ionic-problem-01/","excerpt":"","text":"Ionic root 문제ionic을 사용하다 보면 페이지 컨트롤을 위해서 자연적으로 NavController를 사용하게 되는데, 정확히 파악하지 않은 상태에서 NavCtrl을 사용하다 보니 내가 생각했던 구조대로 앱이 만들어지지 않고 있다는 것을 깨닫게 되었다. 문제점우선 내가 의도한 구조는 이렇다123456789101112131415app&lt;Nav&gt;&#123; LoginPage, UserPage&lt;Nav&gt;:[ page1, page2, page3, ..... ], StudyPage&lt;Nav&gt;:[ page1, page2, page3, ..... ],&#125; 하지만 내가 만든 구조는 이렇게 되어있었다.123456789101112131415app&lt;Nav&gt;&#123; LoginPage, UserPage&lt;Nav&gt;:[ page1, page2, page3, ..... StudyPage&lt;Nav&gt;:[ page1, page2, page3, ..... ] ]&#125; 상황이 심각하다. 문제인식구조가 잘못되고 있다는것을 인식한 것은 UserPage에서 생성한 css 가 StudyPage에 영향을 미치고 있는걸 보고 알게 되었다. 기본적으로 ionic은 각 페이지 별로 css 정의를 할 수 있고, 자식 컴포넌트가 아니면 css간 영향이 없다. 원인공식 홈페이지나 구글링을 통해 얻을 수 있는 Tutorial 을 따라하다 보면 navCtrl.push(), navCtrl.pop(), navCtrl.setRoot() 에 관한 설명은 잘 되어있으나 그 이상은 설명되어 있지 않으며 여기서 필자의 경우엔 setRoot() 의 작동방식을 착각한 것이 원인이었다. 해결여기 저기에서 사용한 setRoot()는 해당 컴포넌트에 ion-nav 를 사용하지 않으면 부모 컴포넌트의 ion-nav 를 바꿔주었지만, 컴포넌트에 ion-nav 가 있는 경우 해당 컴포넌트의 ion-nav를 바꿔준다. 그래서 최상단의 navCtrl을 가져오기 위해선 App을 가져와야 한다. 12345678910111213141516171819import &#123; App, NavCtroller, NavParams&#125; from 'ionic-angular';....@Component(&#123; selector: 'your-selector', templateUrl: 'your-template.html'&#125;)export class YourPage&#123; constructor( public navCtrl: NavController, public navParams: NavParams, public appCtrl: App )&#123;&#125; ........... moveToPage()&#123; // getRootNav()는 최상단의 nav를 가져온다. this.appCtrl.getRootNav().setRoot(NextPage); &#125;&#125; 출처stack overflow","categories":[{"name":"문제해결","slug":"문제해결","permalink":"https://jumpegg.github.io/categories/문제해결/"}],"tags":[{"name":"ionic-root","slug":"ionic-root","permalink":"https://jumpegg.github.io/tags/ionic-root/"}]},{"title":"ionic-menu","slug":"ionic-menu","date":"2017-07-12T08:59:02.000Z","updated":"2017-07-20T05:46:59.497Z","comments":true,"path":"2017/07/12/ionic-menu/","link":"","permalink":"https://jumpegg.github.io/2017/07/12/ionic-menu/","excerpt":"","text":"IONIC Menu 사용법ionic menu 사용ion-menu 는 사이드 메뉴를 만드는데 사용된다.12345678910&lt;!-- 템플릿 사이드 코드 --&gt;&lt;ion-menu [content]=\"mycontent\"&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;p&gt;some menu content, could be list items&lt;/p&gt; &lt;/ion-list&gt; &lt;/ion-content&gt;&lt;/ion-menu&gt;&lt;ion-nav #mycontent [root]=\"rootPage\"&gt;&lt;/ion-nav&gt; 사이드 메뉴를 열 수 있는 버튼 생성 1234&lt;button menuToggle&gt; &lt;ion-icon name=\"menu\"&gt;&lt;/ion-icon&gt;&lt;/button&gt; 1234567891011121314151617181920212223import &#123; Component &#125; from '@angular/core';import &#123; MenuController &#125; from 'ionic-angular';@Component(&#123;...&#125;)export class MyPage &#123; constructor(public menuCtrl: MenuController) &#123; &#125; openMenu() &#123; this.menuCtrl.open(); &#125; closeMenu() &#123; this.menuCtrl.close(); &#125; toggleMenu() &#123; this.menuCtrl.toggle(); &#125;&#125;","categories":[{"name":"ionic2","slug":"ionic2","permalink":"https://jumpegg.github.io/categories/ionic2/"}],"tags":[{"name":"ionic2-menu","slug":"ionic2-menu","permalink":"https://jumpegg.github.io/tags/ionic2-menu/"}]},{"title":"CH 4 트랜잭션(4.2, 4.3)","slug":"mysql-transection2","date":"2017-07-12T05:45:19.000Z","updated":"2017-07-15T01:30:21.615Z","comments":true,"path":"2017/07/12/mysql-transection2/","link":"","permalink":"https://jumpegg.github.io/2017/07/12/mysql-transection2/","excerpt":"","text":"4.2 Mysql 엔진의 잠금Mysql 에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 Mysql 엔진 레벨로 나눠볼 수 있다. Mysql 엔진은 Mysql 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 되는데, Mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다. 4.2.1 글로벌 락 (Global Lock)글로벌락은 “flush tables with read lock” 명령으로만 획득할 수 있으며, Mysql에서 제공하는 잠금 가운데 가장 범위가 크다. 글로벌 락이 영향을 미치는 범위는 Mysql 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르다 하더라도 동일하게 영향을 미친다. 4.2.2 테이블 락 (Table Lock)개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 명시적으로는 “lock tables table_name [READ | WRITE]” 명령으로 특정 테이블의 락을 획득할 수 있다. 테이블 락은 MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다. 명시적으로 획득한 잠금은 “Unlock Tables” 명령으로 잠금을 반납(해제) 할 수 있다. 4.2.3 유저 락 (User Lock)Get_lock() 함수를 이용해 임의로 잠금을 설정할 수 있다. 이 잠금의 특징은 대상이 테이블이나 레코드 또는 Auto_increment 와 같은 데이터베이스 객체가 아니라는 것이다. 유저락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다. 여러 클라이언트가 상호 동기화를 처리해야 할때 데이터베이스의 유저 락을 이용하면 쉽게 해결할 수 있다. 또한 유저락은 많은 레코드를 한번에 변경해야 하는 트랜잭션의 경우에 유용하게 사용할 수 있다. 배치 프로그램처럼 한번에 많은 레코드를 변경하는 경우 데드락의 원인이 되곤 한다. 이때 동일한 데이터를 변경하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다. 4.2.4. 네임 락 (Name Lock)데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금이다. 네임 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 “Rename table tab_a To tab_b” 같은 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다. 4.3 MyISAM 과 MEMORY 스토리지 엔진의 잠금MyISAM 이나 MEMORY 스토리지 엔진은 자체적인 잠금을 가지지 않고 MYSQL 엔진에서 제공하는 테이블 락을 그대로 사용한다. 그리고 MyISAM 이나 MEMORY 스토리지 엔진에서는 쿼리 단위로 필요한 잠금을 한꺼번에 요청해서 획득하기 때문에 데드락이 발생할 수 없다. 4.3.1 잠금 획득 읽기 잠금테이블에 쓰기 잠금이 걸려 있지 않으면 바로 일기 잠금을 획득하고 읽기 작업을 시작할 수 있다. 쓰기 잠금테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금을 획득할 수 있고, 그렇지 않다면 다른 잠금이 해제될 때까지 대기해야 한다. 4.3.2 잠금 튜닝테이블 락에 대한 작업 상황은 MYSQL 의 상태 변수를 통해 확인할 수 있다. 12345678mysql&gt; show status like 'Table%';+-----------------------+---------+| Variable_name | Value |+-----------------------+---------+| Table_locks_immediate | 1551552 || Table_locks_waited | 15324 |+-----------------------+---------+ Table_locks_immediate 는 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수이며, Table_locks_waited 는 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장하고 있다. 잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_immediate + Table_locks_waited) * 100; 위의 수치들을 대입해보면 약 1.31% 의 수치를 얻을 수 있으며, 이는 100개의 쿼리중 1개는 잠금 대기를 겪고 있다는 것을 알 수 있다. 4.3.3 테이블 수준의 잠금 확인 및 해제MYISAM 이나 MEMORY 등과 같은 스토리지 엔진을 사용하는 테이블은 모두 테이블 단위의 잠금이므로 테이블을 해제하지 않으면 다른 클라이언트에서 그 테이블을 사용하는 것이 불가능하다. MYSQL 에서 현재 어떤 테이블이 잠겨있는지 확인하는 방법을 알아보자 MYSQL에서 테이블의 잠금을 획득하는 방법은 LOCK TABLES 명령을 이용해 명시적으로 획득하는 방법과, 쿼리문을 통한 묵시적 잠금획득 방법이 있다. 명시적인 방법은 UNLOCK TABLES 명령으로 해제하기 전에는 자동으로 해제되지 않는다. 아무런 옵션 없이 SHOW OPEN TABLES 명령을 바로 실행하면 MYSQL 서버의 모든 테이블에 대해 잠금 여부를 보여주고, FROM DB명 을 추가하면 해당 DB에 생성된 테이블에 대해 잠금 상태를 표시한다. SHOW OPEN TABLES 명령의 결과로 출력되는 in_use 값은 해당 테이블을 잠그고 있는 클라이언트 수와 테이블의 잠금을 기다리는 클라이언트의 수까지 더해서 출력된다. 그리고 “Name_locked” 는 테이블 이름에 대한 네임 락이 걸려 있는지를 표시한다. 어떤 클라이언트의 커넥션이 잠금을 기다리고 있는지 보려면 SHOW PROCESSLIST 명령을 사용해야 한다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"transection","slug":"transection","permalink":"https://jumpegg.github.io/tags/transection/"}]},{"title":"CH 4 트랜젝션(4.1)","slug":"mysql-transection1","date":"2017-07-12T03:41:19.000Z","updated":"2017-07-12T05:33:51.470Z","comments":true,"path":"2017/07/12/mysql-transection1/","link":"","permalink":"https://jumpegg.github.io/2017/07/12/mysql-transection1/","excerpt":"","text":"Mysql 에서 동시성에 영향을 주는 잠금(lock) 과 트랜잭션, 그리고 트랜잭션의 격리수준(isolation level) 을 살펴보겠다. 잠금(lock) 과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 4.1 트랜잭션4.1.1 Mysql에서의 트랜잭션트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나(commit을 실행했을 때) 또는 아무것도 적용되지 않아야 (RollBack 또는 Transection Rollback 시키는 오류가 발생했을 때) 함을 보장해 주는 것이다. 12345mysql&gt; create table tab_myisam (fdpk int not null, primary key(fdpk)) engine=MyISAM;mysql&gt; insert into tab_myisam (fdpk) values (3);mysql&gt; create table tab_innodb (fdpk int not null, primary key (fdpk)) engine=innoDB;mysql&gt; insert into tab_innodb (fdpk) values (3); 위와같이 테스트 테이블을 생성 후 auto-commit 모드에서 다음 쿼리 문장을 실행해 보자 12mysql&gt; insert into tab_myisam (fdpk) values (1), (2), (3);mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3); 두 개의 스토리지 엔진에서 결과가 어떻게 다를까? 위 쿼리 문장의 테스트 결과는 다음과 같다. 123456789101112131415161718192021mysql&gt; Insert into tab_myisam (fdpk) values (1), (2), (3);error 1062 ......mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3);error 1062 ...mysql&gt; select * from tab_myisam;+-------+| fdpk |+-------+| 1 || 2 || 3 |+-------+mysql&gt; select * from tab_innodb;+-------+| fdpk |+-------+| 3 |+-------+ MyISAM의 경우 오류가 발생했음에도 1,2 가 들어가 있다. MyISAM 테이블에 insert 문장이 실행되면서 차례대로 1,2를 저장하고 그 다음 3을 저장하려는 순간 중복키 오류가 발생한 것이다. InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만들어 둔다는 트랜잭션의 원칙대로 insert 쿼리 문장을 실행하기 전 상태로 그대로 복구했다. MyISAM에서 발생하는 이런 현상을 부분 업데이트(partial update)라고 하며, 이것은 테이블 데이터의 정합성을 맞추는데 상당한 어려움을 유발시킨다. 4.1.2 주의사항트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 이는 프로그램 코드에서 트랜잭션의 범위를 최소화 하라는 의미다. 설명을 위해 간단한 예를 들어보자 처리시작 =&gt; 데이터베이스 커넥션 생성 =&gt; 트랜잭션 시작 사용자의 로그인 여부 확인 사용자의 글쓰기 내용의 오류 여부 확인 첨부로 업로드된 파일 확인 및 저장 사용자의 입력 내용을 DBMS에 저장 첨부 파일 정보를 DBMS에 저장 저장된 내용 또는 기타 정보를 DBMS에서 조회 게시물 등록에 대한 알림 메일 발송 알림 메일 발송 이력을 DBMS에 저장 &lt;= 트랜잭션 종료 (commit) &lt;= 데이터베이스 커넥션 반납 처리 완료 위 처리절차 중에 DBMS의 트랜잭션 처리에 좋지 않은 영향을 끼치는 부분을 나눠서 살펴보자 커넥션 생성을 1과 2번 사이에 구현했는데 DB의 사용은 5~9 사이에 이루어진다. DB의 커넥션은 제한적이라 커넥션 유지 부분을 짧게 작성 할 수록 좋다. 8번의 메일전송이나 FTP 파일 전송작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게든 트랜잭션 내에서 제거하는 것이 좋다. 프로그램 실행 중에 메일서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생 할 것이다. 위의 과정 중 5,6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번작업은 저장된 데이터의 단순 확인작업이므로 트랜잭션에 포함시킬 필요 없다. 9번작업은 이전 5,6 번 작업과 성격이 다르기 때문에 같은 트랜잭션으로 묶을 필요가 없다. 이러한 내용을 적용시켜 재설계 해보자 처리 시작 사용자의 로그인 여부 확인 사용자의 클쓰기 내용의 오류 발생 여부 확인 첨부로 업로드된 파일 확인 및 저장 =&gt; 데이터베이스 커넥션 생성 =&gt; 트랜잭션 시작 사용자의 입력 내용을 DBMS에 저장 첨부 파일 정보를 DBMS에 저장 &lt;= 트랜잭션 종료 저장된 내용 또는 기타 정보를 DBMS에서 조회 게시물 등록에 대한 알림 메일 발송 =&gt; 트랜잭션 시작 알림 메일 발송 이력을 DBMS에 저장 &lt;= 트랜잭션 종료 &lt;= 데이터베이스 커넥션 종료 처리 완료","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"transection","slug":"transection","permalink":"https://jumpegg.github.io/tags/transection/"}]},{"title":"Ionic Guard 구현","slug":"Ionic-nav-guard","date":"2017-07-09T05:23:41.000Z","updated":"2017-07-12T08:59:34.949Z","comments":true,"path":"2017/07/09/Ionic-nav-guard/","link":"","permalink":"https://jumpegg.github.io/2017/07/09/Ionic-nav-guard/","excerpt":"","text":"Lifecyle 을 이용한 구현Angular 에서는 route 부분에서 guard를 구현해 해당 페이지에 접근가능/불가 를 제어한다. ionic에서는 해당 기능을 lifecycle을 통해 제공하고 있다. ionViewCanEnter / ionViewCanLeaveNavController에 ionViewCanEnter 와 ionViewCanLeave 는 페이지의 접근 관련제어를 담당하고 있다. ionViewCanLeave 예제 1234567891011121314151617export class MyClass&#123; constructor( public navCtrl: NavController )&#123;&#125; pushPage()&#123; this.navCtrl.push(DetailPage); &#125; ionViewCanLeave(): boolean&#123; if(isValid(CanILeave))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; ionViewCanEnter 예제 1234567891011121314151617181920212223export class MyClass&#123; constructor( public navCtrl: NavController )&#123;&#125; pushPage()&#123; this.navCtrl.push(DetailPage); &#125;&#125;export class DetailPage()&#123; constructor( public navCtrl: NavController )&#123;&#125; ionViewCanEnter(): boolean&#123; if(isValid(CanIEnter))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; ionViewCanEnter, ionViewCanLeave 둘 다 boolean/Promise 의 리턴 형태를 가지고 있으므로 형태에 맞게 사용하면 되겟다","categories":[{"name":"ionic2","slug":"ionic2","permalink":"https://jumpegg.github.io/categories/ionic2/"}],"tags":[{"name":"ionic2-nav","slug":"ionic2-nav","permalink":"https://jumpegg.github.io/tags/ionic2-nav/"}]},{"title":"3. Mysql 아키텍처(3.7, 3.8)","slug":"Mysql-architecture4","date":"2017-07-08T14:41:26.000Z","updated":"2017-07-12T05:45:41.224Z","comments":true,"path":"2017/07/08/Mysql-architecture4/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture4/","excerpt":"","text":"3.7 전문 검색 엔진(Fulltext search engine)최근 인터넷 서비스는 대부분 본문 검색이 기본적으로 포함되는 경우가 많은데, 이러한 요건은 전문 검색 엔진 없이는 구현하기가 쉽지 않다. 여기서는 한글을 지원하고, 어느정도 수준의 성능을 보장하고 있는 트리톤과 스핑크스라는 검색엔진을 간단하게 살펴본다. 3.7.1 트리톤 전문 검색 엔진트리톤을 사용하려면 먼저 Mysql의 소스코드를 패치한 후, 다시 빌드해야 하며 그 이후에 InnoDB같이 하나의 스토리지 엔진으로 사용할 수 있다. 한, 중, 일 아시아권 언어 지원이 강점이며 또한 세나(Senna) 라이브러리를 이용한 빠른 인덱싱과 검색을 제공한다. 또한 Mysql 서버의 전문 검색엔진과 달리 N-그램 방식의 인덱싱도 사용할 수 있다는 것이 가장 큰 장점이다. 3.7.2 mGroonga 전문 검색 엔진(플러그인)트리톤은 Mysql 5.0.87 버전에서만 사용할 수 있다. 트리톤을 5.1, 5.5 버전에서 사용해야 한다면 트리톤의 후속작인 Groonga 라는 전문 검색 엔진을 사용해야 한다. 하지만 Groonga는 Mysql과 전혀 연관없이 독립적으로 기동하는 소프트웨어라서 Mysql에 익숙한 사용자를 위해 mGroonga 라는 플러그인을 함께 제공한다. 3.7.3 스핑크스 전문 검색 엔진스핑크스는 Mysql 서버와는 전혀 연관이 없이 자체적인 저장 공간을 가지고 별도의 프로세스로 작동하며, Mysql 서버를 통해 접근할 수 있는 인터페이스만 제공하는 형태의 스토리지 엔진이다. N-그램방식의 인덱싱과 UTF-8 언어를 지원하는것과 분산처리 기능이 상당히 뛰어나다는 것이 장점이다. 3.8 Mysql 로그 파일3.8.1 에러 로그 파일Mysql이 실행되는 도중에 발생하는 에러나 경고 메세지가 출력되는 로그 파일이다. 에러 로그 파일의 위치는 configure 파일에 “log_error” 라는 이름의 파라미터에 정의된 경로에 있는 파일이거나, 별도로 지정되지 않은 경우에는 데이터 디렉터리에 “.err” 확장자가 붙은 파일이다. 여러가지 메시지가 다양하게 출력되지만 다음에 소개되는 메시지를 가장 자주 보게 될 것이다. Mysql 이 시작하는 과정과 관련된 정보성 및 에러 메시지 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지 비정상적으로 종료된 커넥션 메시지 InnoDB의 모니터링 명령이나 상태 조회 명령의 결과 메시지 Mysql 종료 메시지 3.8.2 제너럴 쿼리 로그 파일쿼리 로그파일은 configure 파일의 “general-log” 라는 이름의 파라메터에 정의된 경로에 있는 파일이고 Mysql 5.1.12 이상의 버전에서는 “general_log_file” 이라는 이름의 파라메터에 정의된 경로에 있는 파일이다. 3.8.3 슬로우 쿼리 로그Mysql 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영중에 Mysql 서버의 전체적인 성능 저하를 검사하거나 또는 정기적인 점검을 위한 튜닝으로 나눌 수 있다. 전자의 경우에는 검토해야 할 대상 쿼리가 전부라서 모두 튜닝하면 되지만, 후자의 경우에는 어떤 쿼리가 문제의 쿼리인지 판단하기가 상당히 어렵다. 이런 경우에 서비스에서 사용되고 있는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는데 슬로우 쿼리 로그가 상당히 많은 도움이 된다. 슬로우 쿼리 로그 파일에는 configure 에서 정의한 시간(long_query_time) 이상의 시간이 소요된 쿼리가 모두 기록된다. 실제 소요된 시간을 기준으로 기록 여부를 판단하기 때문에 정상적으로 실행된 쿼리만 기록된다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍처(3.4, 3.5, 3.6)","slug":"Mysql-architecture3","date":"2017-07-08T13:22:33.000Z","updated":"2017-07-12T05:45:37.028Z","comments":true,"path":"2017/07/08/Mysql-architecture3/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture3/","excerpt":"","text":"3.4 Memory 스토리지 엔진 아키텍처Memory 스토리지 엔진은 Heap 스토리지 엔진 이라고도 하는데, 이름 그대로 데이터를 메모리에 저장하는 것이 특징이다. 데이터의 크기가 작고 아주 빠른 처리가 필요한 경우 적합한 엔진이다. 3.4.1 주의사항테이블의 최대 크기다른 스토리지 엔진을 이용한 테이블과는 달리 Memory 스토리지 엔진을 사용하는 테이블은 저장할 수 있는 데이터의 최대 용량이 정해져 있다. 최대 데이터의 크기는 max_heap_table_size 파라미터로 정의한다 고정 길이 칼럼만 지원Memory 테이블의 모든 칼럼은 항상 고정 길이로만 생성된다. 즉 varchar(100)와 같은 타입의 칼럼을 만들어도 char(100)과 동일하게 공간이 할당된다는 의미이다. 따라서 불필요하게 너무 큰 데이터 타입을 사용하지 않는 것이 좋다. Blob 이나 Text와 같은 LOB(Large Object) 타입은 지원하지 않음Memory 테이블은 기본적으로 해시 인덱스 사용InnoDB나 MyISAM 테이블을 생성할 때 별다른 내용을 명시하지 않으면 기본적으로 B-Tree 인덱스가 생성되지만 Memory 스토리지 엔진을 사용하면 해시 인덱스를 생성한다. 3.4.2 용도Memory 스토리지는 사실 Mysql 엔진이 쿼리를 처리하는 과정에서 임시로 생성되는 임시 테이블 용도로 자주 사용된다. 3.5 NDB 클러스터 스토리지 엔진NDB 클러스터는 “Network DataBase” 의 줄임말로 일반적으로 NDB 라 불리운다. NDB는 데이터의 분산이나 그로인한 성능 향상 보다는 가용성에 집중된 스토리지 엔진이다. 3.5.1 NDB 클러스터의 특성무공유 클러스터링NDB는 데이터를 저장하는 스토리지가 분산되어 관리되기 때문에 하나의 데이터 저장소가 작동을 멈추더라도 서비스에 영향을 미치지 않는다. 메모리 기반의 스토리지 엔진NDB는 클러스터 노드 간의 빠른 데이터 동기화를 위해 메모리를 사용한다. NDB 클러스터는 데이터 스토리지까지 분산하기 때문에 각 노드의 물리적 메모리를 모두 합친 것이 실제 저장 가능한 최대 용량이 된다. 자동화된 Fail-overNDB는 모든 구성 노드가 서로의 상태를 계속 체크하고 있기 때문에 특정 노드에 문제가 발생해도 다른 사용 가능한 노드가 그 역할을 이어받는 형태로 페일 오버가 가능하다. 분산된 데이터 저장소간의 동기 방식(Sync) 복제NDB에서 데이터 저장소는 분산되어 관리되는데, 각 데이터 저장소는 전체 데이터를 N등분해서 자신이 전담하는 파티션과 백업으로 보조 파티션을 구성한다. 각 데이터 저장소는 분산된 서로의 데이터를 동기화 해야 하는데 NDB는 비동기 방식이 아닌 동기 방식으로 서로의 데이터를 전달한다. 온라인 스키마 변경NDB는 테이블에 칼럼이나 인덱스를 추가하면서 동시에 Insert 나 Update와 같은 DML 쿼리를 처리할 수 있다. 이를 온라인 스키마 변경이라 하는데 사용하는 방법은 Alter table 이나 Create index 명령에 Online 키워드를 사용하면 된다. Online 키워드를 사용하지 않은 스키마 변경 쿼리(DDL)은 클러스터가 온라인 처리 유무를 판단하고 가능한 경우 온라인 방식으로 처리한다. NoSql네트워크 DBNDB는 내부적으로 데이터를 저장하고 읽기 위해 네트워크를 기반으로 작동한다. 이는 하나의 서버에서 모든 처리가 일어나는 다른 스토리지 엔진과는 상당히 다른 개념이다 3.5.2 NDB 클러스터의 아키텍처NDB 클러스터 노드의 종류 관리노드 관리노드는 실제 NDB가 정상 상태에서 서비스되는 도중에는 거의 하는 일이 없다. 관리노드는 NDB 클러스터의 전체적인 구조에 대한 정보를 다른 노드에게 전파하거나 각 노드의 장애 상황을 전파하는 역할을 담당한다. 데이터 노드 데이터 노드는 클러스터에 대한 전반적인 작업을 수행하는 노드다. 대표적으로는 데이터를 저장하는 스토리지를 관리하고 SQL 노드에서 오는 데이터 조작 요청을 모두 처리한다. 또한 SQL 노드가 아닌 API 노드의 요청도 처리한다. 기본적으로 데이터에 관련된 모든 요청을 데이터 노드가 처리한다고 이해하면 된다. SQL 노드 NDB에 접속해 데이ㅓ를 읽고 쓰는 방법은 Mysql 서버를 통해 Sql 문법으로 처리할 수도 있지만 자바나 C 같은 프로그래밍 언어를 이용해 클러스터의 데이터를 조작할 수도 있다. 후자의 방법은 NDB API를 이용하는 방법으로 API 노드라고 표현한다. 반면 SQL서버를 이용해 NDB에 접속하는 경우를 SQL 노드라고 한다. 데이터 노드 간의 파티션 관리NDB 클러스터는 데이터 노드가 손상되어도 서비스가 가능하도록 클러스터 데이터를 파티션해서 각 파티션을 최소 2개 이상의 데이터 노드에 복제해둔다. 또한 원활한 관리를 위해 데이터 노드를 노드 그룹으로 나누는데, 노드 그룹에는 반드시 1개 이상의 데이터 노드가 존재해야 하며, 노드 그룹에 속한 데이터 노드는 항상 동일한 데이터 파티션을 가진다. 3.5.3 클러스터 간의 복제 구성NDB 클러스터에도 Mysql의 복제를 적용할 수 있는데, 이런 경우는 특별히 클러스터간 복제라고 표현한다. 3.5.6 NDB 클러스터의 용도처음에 NDB는 이동통신 사용자의 로그인 정보를 저장하는데 있었는데, 가용성이 극대화된, 소위 세션 데이터 전용 데이터베이스를 만드는 것이 목적이었다. 지금도 세션 전용 데이터베이스로 많이 사용되고 있다. 3.6 TOKUDB 스토리지 엔진3.6.1 프랙탈 트리(Fractal Tree) 인덱스 지원B-Tree의 경우 계속되는 Insert, Update, Delete 작업으로 인해 인덱스 페이지 내에 사용되지 못하는 공간이 생기는데 이를 단편화라고 한다. 단편화 현상에 의해 동일한 레코드건수를 조회 하더라도 디스크에서 읽어야 할 인덱스의 숫자가 많아질 수 있고, 버퍼 풀과 같은 캐시영역의 공간도 많이 차지하게 된다. 이러한 현상은 범위 검색과 같은 작업에 비효율성을 발생시킨다. 프랙탈 트리 인덱스는 B-Tree의 단점을 보완한 새로운 형태의 인덱싱 알고리즘이며, 이 알고리즘을 사용한 TokuDB는 프랙탈 트리의 알고리즘 개발자가 설립한 회사에서 출시한 스토리지 엔진이다. 3.6.2 대용량 데이터와 빠른 Insert 처리위와 같은 프랙탈 트리를 사용함으로써 인덱스에 새로운 레코드를 추가하는 작업이 상당히 빨라진다. 3.6.3 트랜잭션 및 잠금 처리3.6.4 그 이외의 특징3.6.5 TokuDB의 주 용도 SNS 기반의 대용량 테이블(동시성을 크게 요하지 않는) 실시간 웹페이지 클릭 분석 웹 서버나 게임 서버의 로그 분석 고성능 웹 크롤링 데이터웨어 하우스","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍처(3.2, 3.3)","slug":"Mysql-architecture2","date":"2017-07-08T09:02:39.000Z","updated":"2017-07-12T05:45:37.713Z","comments":true,"path":"2017/07/08/Mysql-architecture2/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture2/","excerpt":"","text":"3.2 InnoDB 스토리지 엔진 아키텍처3.2.1 InnoDB 스토리지 엔진의 특성PK에 의한 클러스터링InnoDB의 모든 데이터 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉 PK값의 순서대로 디스크에 저장된다는 의미이며, 이로 인해 PK에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다. 잠금이 필요없는 일관된 읽기InnoDB는 MVCC(Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 외래 키 지원InnoDB에서는 외래키를 지원하지만 실무에서는 여러가지 제약때문에 잘 사용하지 않다. 하지만 데이터베이스의 좋은 가이드 역할로 사용이 가능하다. 자동 데드락 감지InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 rollback 이 가장 용이한 트랜잭션을 자동적으로 강제 종료해 버린다. 자동화된 장애 복구오라클의 아키텍처 적용3.2.2 InnoDB 버퍼 풀InnoDB 스토리지 엔젠에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. MyISAM 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 InnoDB의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리하고 있는 것이다. 3.2.3 Undo 로그언두 영역은 update, delete와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다. 언두의 데이터는 크게 두가지 용도로 사용되는데, 첫 번째가 트랜잭션의 롤백 대비용, 두 번째는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 사용된다. 트랜잭션의 격리 수준이라는 개념이 있는데, 이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때, 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준이다. 3.2.4 Insert BufferRDBMS에서 레코드가 insert 되거나 update 될때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다. 그런 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다. InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로 부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 인서트 버퍼(Insert Buffer) 라고 한다. 3.2.5 Redo 로그 및 로그 버퍼쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다. 하지만 이런 작업은 랜덤하게 디스크에 기록해야 하므로 디스크를 바쁘게 만드는 작업이다. 그래서 대부분의 DBMS에는 변경된 데이터를 버퍼링해 두기 위해 InnoDB 버퍼 풀과 같은 장치가 포함되어 있다. 하지만 이 장치만으로는 ACID를 보장할 수 없는데 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 이를 리두 로그 라고 한다. 하지만 사용량이 많은 DBMS 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가 되는데, 이러한 부분을 보완하기 위한 로그 버퍼링이 존재하는데 이 로그 버퍼링에 사용되는 공간이 로그 버퍼 이다. 3.2.6 MVCC(Multi Version Concurrency Control)MVCC는 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB에서는 언두 로그를 이용해 이 기능을 구현한다. update 문장이 실행될 때 기존의 데이터는 언두 로그에 기록되며 새로운 데이터는 InnoDB 버퍼 풀에 기록된다. 즉 하나의 레코드에 대해 두가지 버전의 데이터가 있으며 select문을 이용해 조회를 할 경우 보여지는 데이터는 격리수준에 따라 다르다. 최종적으로 commit 이 되면 레코드의 테이터를 바꾸고, rollback 을 하면 언두 영역에 있는 데이터를 버퍼 풀로 가져온다. 즉 커밋이 된다고 언두 영역의 데이터가 바로 삭제되는게 아니다. 이 언두 영역을 필요로 하는 트랜잭션이 더는 필요 없을 때 비로소 삭제된다. 3.2.7 잠금이 없는 일관된 읽기특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 select 작업을 방해하지 않는다. 이를 잠금이 없는 일관된 읽기 라고 표현하며 InnoDB에서는 언두 로그를 사용하여 구현한다. 3.3 MyISAM 스토리지 엔진 아키텍처3.3.1 키 캐시InnoDB의 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 키 캐시다. 하지만 키 캐시는 인덱스만 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다. 3.3.2 운영체제의 캐시 및 버퍼MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다. 하지만 MyISAM 테이블의 데이터는 디스크로부터의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 그래서 운영체제의 디스크 읽기/쓰기 작업으로 요청될 수 밖에 없다. 운영체제의 캐시 기능은 InnoDB 같이 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지는 못하지만 그래도 없는 것 보다는 낫다. 운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍쳐(3.1)","slug":"Mysql-architecture","date":"2017-07-08T07:37:31.000Z","updated":"2017-07-12T05:37:35.639Z","comments":true,"path":"2017/07/08/Mysql-architecture/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture/","excerpt":"","text":"3.1.1 Mysql 전체적인 구조Mysql 은 크게 Mysql엔진과 스토리지 엔진으로 구분해 볼 수 있다. Mysql 엔진Mysql 엔진은 클라이언트로 부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러 와 SQL 파서 및 전처리기, 그리고 쿼리의 최적화된 실행을 위한 옵티마이저 가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함되 있다. 스토리지 엔진스토리지 엔진은 실질적으로 데이터를 디스크 스토리지에 저장하거나 디스크로 부터 데이터를 읽어오는 부분을 전담한다. Mysql 서버에서 Mysql엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 핸들러 APIMysql 엔진의 쿼리 실행기에서 데이터를 읽기/쓰기 작업을 할때 스토리지에 읽기/쓰기 작업을 요청하는데, 이런 요청작업을 핸들러(Handler) 요청이라 하고, 여기에 사용되는 API를 핸들러API라고 한다. 3.1.2 Mysql 스레딩 구조Mysql은 프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 포그라운드(Foreground)와 백그라운드(Background)로 구분할 수 있다. 포그라운드 스레드포그라운드 스레드는 최소한 Mysql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다. 포그라운드 스레드는 데이터를 Mysql의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리한다. 백그라운드 스레드MyISAM과는 다르게 InnoDB에서는 여러가지 작업이 백그라운드로 처리된다. 그중 가장 중요한것이 로그 스레드(Log thread) 와 버퍼의 데이터를 디스크로 내려 쓰는 작업을 처리하는 쓰기 스레드(Write thread) 이다. 3.1.3 메모리 할당 구조Mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.두 영역의 차이는 Mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지로 구분할 수 있다. 글로벌 메모리 영역일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 로컬 메모리 영역세션 메모리 영역이라고도 표현하며, 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 로컬메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다. 3.1.4 플러그인 스토리지 엔진 모델Mysql의 독특한 구조 중 대표적인 것이 바로 플러그인 모델이다. 쿼리 실행과정에서 데이터 읽기/쓰기 작업이 스토리지 엔진에 의해 처리된다. 복잡한 처리, 예를 들면 group by 나 order by 는 Mysql 의 쿼리 실행기에서 처리가 된다. 여기서 중요한점은 ‘하나의 쿼리 작업’ 은 ‘여러가지 하위 작업’ 으로 나뉘는데 각각의 하위 작업이 어디에서 처리되는지 구분할 줄 알아야 한다.스토리지 엔진은 대표적으로 MyISAM과 InnoDB가 있다. 123mysql&gt; show engines; -- 이 명령어를 통해 지원되는 엔진 확인가능...mysql&gt; show plugins; -- 플러그인 확인 명령어 3.1.5 쿼리 실행구조파서파서는 쿼리문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다. 전처리기파서에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 옵티마이저쿼리문장을 저렴한 비용으로 가장 빠르게 처리할 지 결정하는 역할을 담당한다. 실행 엔진만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다. 핸들러(스토리지 엔진)Mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다. 3.1.6 복제(Replication)데이터가 갈수록 대용량화돼 가는 것을 생각하면 확장성(Scalability)은 DBMS에서 아주 중요한 요소인데, Mysql에서 확장성을 위한 일반적인 기술로는 복제(Replication)를 들어볼 수 있다. 복제는 2대 이상의 Mysql 서버가 동일한 데이터를 담도록 실시간 동기화하는 기술이다. 서버의 역할에 따라서 master 와 slave 로 나눌 수 있다. 복제 주의사항 슬레이브는 하나의 마스터만 설정 가능 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 일기 전용으로 설정 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합 복제가 불필요한 경우에는 바이너리 로그 중지 바이너리 로그와 트랜잭션 격리 수준(Isolation level) 3.1.7 쿼리 캐시쿼리 캐시는 타 DBMS에는 없는 Mysql의 독특한 기능이다. 여러가지 복잡한 처리 절차와 꽤 큰 비용을 들여 실행된 결과를 쿼리 캐시에 담아 두고, 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾아 바로 결과를 준다. 쿼리 캐시는 SQL 문장의 결과는 메모리에 캐시해 두는 기능이다. 쿼리 캐시의 구조는 간단한 키와 값의 쌍으로 관리되는 맵(Map)과 같은 데이터 구조로 구현되 있다. 여기서 키는 쿼리문장 , 값은 쿼리 실행결과 형태로 저장되어 있다. 쿼리 캐시를 사용할 경우 캐시에 있는 쿼리 결과를 넘기기 전에 다음과 같은 확인절차가 필요하다. 요청된 쿼리 문장이 쿼리 캐시에 존재하는가? 해당 사용자가 그 결과를 볼 수 있는 권한을 가지는가? 트랜젝션 내에서 실행된 쿼리인 경우, 그 결과가 가시범위 내의 트랜젝션에서 만들어진 결과인가? 쿼리에 사용된 기능이 캐시되도 동일한 결과를 보장할 수 있는가? Current_date, sysdate, rand 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가? 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가? 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가? 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가? 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가? 이런 제약사항들에도 불구하고 쿼리캐시는 훌륭한 기능이다. 다음을 통해 쿼리캐시 관련 데이터들을 볼 수 있다. 123mysql&gt; show global status like 'Qcache%'; -- 쿼리캐시 관련 데이터....mysql&gt; show global status like 'Com_select'; Qcache_hits는 쿼리캐시로 처리된 select 쿼리의 수를 의미하며, Com_select 쿼리캐시에서 결과를 찾지 못해서 직접 실행한 횟수이다. 즉 Com_select 와 Qcache_hits를 더하면 Mysql 서버로 요청된 모든 select 문장의 총 합이 되는 것이다. 쿼리 캐시 히트율(%) = Qcache_hits/ (Qcache_hits + Com_select) * 100 보통 쿼리캐시 히트율이 20% 이상이면 쿼리캐시를 사용하는 것이 좋다고 한다. 하지만 히트율이 1% 라도 아주 큰 자원을 소모하는 쿼리의 경우 쿼리캐시를 사용하는 것이 좋다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"Ionic 간단한 nav 개념잡기","slug":"ionic-nav","date":"2017-07-07T14:37:10.000Z","updated":"2017-07-12T08:59:28.348Z","comments":true,"path":"2017/07/07/ionic-nav/","link":"","permalink":"https://jumpegg.github.io/2017/07/07/ionic-nav/","excerpt":"","text":"IONIC 간단한 nav 개념잡기기본적인 페이지 이동ionic 은 router 의 개념이 stack을 통해 view 를 push/pop 하는 형식이다.(이것은 한글인가 영어인가….) 1234567891011import &#123;NavController&#125; from 'ionic-angular';.....@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125;&#125; 여기서 클래스 이름 그대로 NavController 가 네비게이션 컨트롤러 역할을 한다. 페이지를 넘기고 싶다면 push 를 이용해서 이동하고 싶은 페이지의 컴포넌트를 입력시키면 된다. 1234567891011121314151617import &#123;NavController&#125; from 'ionic-angular';.....import &#123;SecondPage&#125; from '../Component/SecondPage/SecondPage';@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125; moveToSecond()&#123; this.navCtrl.push(SecondPage); //push 를 이용한 페이지 이동 &#125;&#125; 페이지간 데이터 전송페이지간 데이터를 전송하고 싶다면 push에 파라메터로 넘기고싶은 데이터의 Object를 파라메터로 넘겨주고, 받는 페이지에서는 navParams.get() 을 이용해서 받으면 된다. 파라메터를 넘기는 IndexPage 1234567891011121314151617import &#123;NavController&#125; from 'ionic-angular';.....import &#123;SecondPage&#125; from '../Component/SecondPage/SecondPage';@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125; moveToSecond()&#123; this.navCtrl.push(SecondPage,&#123;msg: \"It's work!!\"&#125;); // 컴포넌트에 msg 라는 파라메터 넘김 &#125;&#125; 파라메터를 받는 SecondPage 12345678910111213141516import &#123;NavController, NavParams&#125; from 'ionic-angular';....@Component(&#123; templateUrl: 'yourSecond.html';&#125;)export class SecondPage&#123; constructor( public navCtrl:NavController, public navParams:NavParams)&#123; &#125; ionViewDidLoad() &#123; console.log(this.navParams.get('msg')); // 파라메터에 접근 &#125;&#125; rootPage 설정페이지가 이동을 하면 새로 root 페이지를 설정해줘야 할 때가 있다. 예를들면 로그인 이후 화면? 같은것을 예로 들 수 있다. setRoot()를 이용하면 root 페이지를 바꿀 수 있다. 1234567891011121314151617import &#123;NavController, NavParams&#125; from 'ionic-angular';....@Component(&#123; templateUrl: 'yourSecond.html';&#125;)export class SecondPage&#123; constructor( public navCtrl:NavController, public navParams:NavParams)&#123; &#125; ionViewDidLoad() &#123; console.log(this.navParams.get('msg')); // 파라메터에 접근 this.navCtrl.setRoot(SecondPage); // SecondPage로 root를 바꾼다 &#125;&#125; setRoot() 사용시 주의점은 root를 바꿔주면서 해당 페이지로 이동시키기 때문에 setRoot() 를 사용하는 지점을 잘 생각해야 한다. 실수로 자기 자신을 루트로 잡아봤는데 무한루프가 도는 것을 볼 수 있었다. 참조 사이트http://www.joshmorony.com/a-simple-guide-to-navigation-in-ionic-2/고 투 더 멘토","categories":[{"name":"ionic2","slug":"ionic2","permalink":"https://jumpegg.github.io/categories/ionic2/"}],"tags":[{"name":"ionic2-nav","slug":"ionic2-nav","permalink":"https://jumpegg.github.io/tags/ionic2-nav/"}]},{"title":"Hexo 를 시작해보자","slug":"start","date":"2017-07-06T09:15:19.000Z","updated":"2017-07-06T09:31:29.888Z","comments":true,"path":"2017/07/06/start/","link":"","permalink":"https://jumpegg.github.io/2017/07/06/start/","excerpt":"","text":"hexo 가 있는건 진작 알고 있었는데, 혼자 하는 프로젝트가 어느정도 끝나가면서 사용했던 개념들을 기록 할 공간이 필요했다. 그래서 이번에 기록 할 겸 hexo도 사용해볼겸 해서 블로그를 시작하게 되었다. 우선 hexo 를 시작해보자 Hexo 를 시작해보자hexo 설치1$ npm install -g hexo-cli cli 환경이 익숙치 않은 사람들에게는 낯설겠지만 hexo 는 cli 환경에서 페이지를 생성하고 markdown 문법을 사용해서 내용을 구성한다. 아무튼, 명령어를 치면 이제 hexo 명령어 들을 사용할 수 있다. hexo init1$ hexo init [폴더명] init 명령어를 사용하면 해당 폴더에 hexo를 사용하기 위한 기본 구조와 파일들이 생성된다 이제 생성한 폴더에 들어가서 hexo 명령어들을 이용해서 작업하면 된다. hexo new1$ hexo new [포스트명] 폴더 안으로 들어가서 new 명령어를 실행하면 [포스트명] 으로 source/_posts/ 폴더안에 파일이 생성된다. 이 파일들이 우리가 만드는 컨텐츠가 된다.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jumpegg.github.io/categories/Hexo/"}],"tags":[]}]}