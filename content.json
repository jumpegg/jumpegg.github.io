{"meta":{"title":"Wonny's note","subtitle":null,"description":null,"author":"Wonny","url":"https://jumpegg.github.io"},"pages":[],"posts":[{"title":"CH 4 트랜젝션(4.1)","slug":"mysql-transection1","date":"2017-07-12T03:41:19.000Z","updated":"2017-07-12T05:32:09.002Z","comments":true,"path":"2017/07/12/mysql-transection1/","link":"","permalink":"https://jumpegg.github.io/2017/07/12/mysql-transection1/","excerpt":"","text":"Mysql 에서 동시성에 영향을 주는 잠금(lock) 과 트랜잭션, 그리고 트랜잭션의 격리수준(isolation level) 을 살펴보겠다. 잠금(lock) 과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 4.1 트랜잭션4.1.1 Mysql에서의 트랜잭션트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나(commit을 실행했을 때) 또는 아무것도 적용되지 않아야 (RollBack 또는 Transection Rollback 시키는 오류가 발생했을 때) 함을 보장해 주는 것이다. 12345mysql&gt; create table tab_myisam (fdpk int not null, primary key(fdpk)) engine=MyISAM;mysql&gt; insert into tab_myisam (fdpk) values (3);mysql&gt; create table tab_innodb (fdpk int not null, primary key (fdpk)) engine=innoDB;mysql&gt; insert into tab_innodb (fdpk) values (3); 위와같이 테스트 테이블을 생성 후 auto-commit 모드에서 다음 쿼리 문장을 실행해 보자 12mysql&gt; insert into tab_myisam (fdpk) values (1), (2), (3);mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3); 두 개의 스토리지 엔진에서 결과가 어떻게 다를까? 위 쿼리 문장의 테스트 결과는 다음과 같다. 123456789101112131415161718192021mysql&gt; Insert into tab_myisam (fdpk) values (1), (2), (3);error 1062 ......mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3);error 1062 ...mysql&gt; select * from tab_myisam;+-------+| fdpk |+-------+| 1 || 2 || 3 |+-------+mysql&gt; select * from tab_innodb;+-------+| fdpk |+-------+| 3 |+-------+ MyISAM의 경우 오류가 발생했음에도 1,2 가 들어가 있다. MyISAM 테이블에 insert 문장이 실행되면서 차례대로 1,2를 저장하고 그 다음 3을 저장하려는 순간 중복키 오류가 발생한 것이다. InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만들어 둔다는 트랜잭션의 원칙대로 insert 쿼리 문장을 실행하기 전 상태로 그대로 복구했다. MyISAM에서 발생하는 이런 현상을 부분 업데이트(partial update)라고 하며, 이것은 테이블 데이터의 정합성을 맞추는데 상당한 어려움을 유발시킨다. 4.1.2 주의사항트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 이는 프로그램 코드에서 트랜잭션의 범위를 최소화 하라는 의미다. 설명을 위해 간단한 예를 들어보자 처리시작 =&gt; 데이터베이스 커넥션 생성 =&gt; 트랜잭션 시작 사용자의 로그인 여부 확인 사용자의 글쓰기 내용의 오류 여부 확인 첨부로 업로드된 파일 확인 및 저장 사용자의 입력 내용을 DBMS에 저장 첨부 파일 정보를 DBMS에 저장 저장된 내용 또는 기타 정보를 DBMS에서 조회 게시물 등록에 대한 알림 메일 발송 알림 메일 발송 이력을 DBMS에 저장 &lt;= 트랜잭션 종료 (commit) &lt;= 데이터베이스 커넥션 반납 처리 완료 위 처리절차 중에 DBMS의 트랜잭션 처리에 좋지 않은 영향을 끼치는 부분을 나눠서 살펴보자 커넥션 생성을 1과 2번 사이에 구현했는데 DB의 사용은 5~9 사이에 이루어진다. DB의 커넥션은 제한적이라 커넥션 유지 부분을 짧게 작성 할 수록 좋다. 8번의 메일전송이나 FTP 파일 전송작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게든 트랜잭션 내에서 제거하는 것이 좋다. 프로그램 실행 중에 메일서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생 할 것이다. 위의 과정 중 5,6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번작업은 저장된 데이터의 단순 확인작업이므로 트랜잭션에 포함시킬 필요 없다. 9번작업은 이전 5,6 번 작업과 성격이 다르기 때문에 같은 트랜잭션으로 묶을 필요가 없다. 이러한 내용을 적용시켜 재설계 해보자 처리 시작 사용자의 로그인 여부 확인 사용자의 클쓰기 내용의 오류 발생 여부 확인 첨부로 업로드된 파일 확인 및 저장 =&gt; 데이터베이스 커넥션 생성 =&gt; 트랜잭션 시작 사용자의 입력 내용을 DBMS에 저장 첨부 파일 정보를 DBMS에 저장 &lt;= 트랜잭션 종료 저장된 내용 또는 기타 정보를 DBMS에서 조회 게시물 등록에 대한 알림 메일 발송 =&gt; 트랜잭션 시작 알림 메일 발송 이력을 DBMS에 저장 &lt;= 트랜잭션 종료 &lt;= 데이터베이스 커넥션 종료 처리 완료","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"transection","slug":"transection","permalink":"https://jumpegg.github.io/tags/transection/"}]},{"title":"Ionic Guard 구현","slug":"Ionic-nav-guard","date":"2017-07-09T05:23:41.000Z","updated":"2017-07-09T05:38:49.588Z","comments":true,"path":"2017/07/09/Ionic-nav-guard/","link":"","permalink":"https://jumpegg.github.io/2017/07/09/Ionic-nav-guard/","excerpt":"","text":"Lifecyle 을 이용한 구현Angular 에서는 route 부분에서 guard를 구현해 해당 페이지에 접근가능/불가 를 제어한다. ionic에서는 해당 기능을 lifecycle을 통해 제공하고 있다. ionViewCanEnter / ionViewCanLeaveNavController에 ionViewCanEnter 와 ionViewCanLeave 는 페이지의 접근 관련제어를 담당하고 있다. ionViewCanLeave 예제 1234567891011121314151617export class MyClass&#123; constructor( public navCtrl: NavController )&#123;&#125; pushPage()&#123; this.navCtrl.push(DetailPage); &#125; ionViewCanLeave(): boolean&#123; if(isValid(CanILeave))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; ionViewCanEnter 예제 1234567891011121314151617181920212223export class MyClass&#123; constructor( public navCtrl: NavController )&#123;&#125; pushPage()&#123; this.navCtrl.push(DetailPage); &#125;&#125;export class DetailPage()&#123; constructor( public navCtrl: NavController )&#123;&#125; ionViewCanEnter(): boolean&#123; if(isValid(CanIEnter))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; ionViewCanEnter, ionViewCanLeave 둘 다 boolean/Promise 의 리턴 형태를 가지고 있으므로 형태에 맞게 사용하면 되겟다","categories":[{"name":"ionic2","slug":"ionic2","permalink":"https://jumpegg.github.io/categories/ionic2/"}],"tags":[{"name":"ionic2 nav","slug":"ionic2-nav","permalink":"https://jumpegg.github.io/tags/ionic2-nav/"}]},{"title":"3. Mysql 아키텍처 3.7, 3.8","slug":"Mysql-architecture4","date":"2017-07-08T14:41:26.000Z","updated":"2017-07-08T15:03:28.769Z","comments":true,"path":"2017/07/08/Mysql-architecture4/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture4/","excerpt":"","text":"3.7 전문 검색 엔진(Fulltext search engine)최근 인터넷 서비스는 대부분 본문 검색이 기본적으로 포함되는 경우가 많은데, 이러한 요건은 전문 검색 엔진 없이는 구현하기가 쉽지 않다. 여기서는 한글을 지원하고, 어느정도 수준의 성능을 보장하고 있는 트리톤과 스핑크스라는 검색엔진을 간단하게 살펴본다. 3.7.1 트리톤 전문 검색 엔진트리톤을 사용하려면 먼저 Mysql의 소스코드를 패치한 후, 다시 빌드해야 하며 그 이후에 InnoDB같이 하나의 스토리지 엔진으로 사용할 수 있다. 한, 중, 일 아시아권 언어 지원이 강점이며 또한 세나(Senna) 라이브러리를 이용한 빠른 인덱싱과 검색을 제공한다. 또한 Mysql 서버의 전문 검색엔진과 달리 N-그램 방식의 인덱싱도 사용할 수 있다는 것이 가장 큰 장점이다. 3.7.2 mGroonga 전문 검색 엔진(플러그인)트리톤은 Mysql 5.0.87 버전에서만 사용할 수 있다. 트리톤을 5.1, 5.5 버전에서 사용해야 한다면 트리톤의 후속작인 Groonga 라는 전문 검색 엔진을 사용해야 한다. 하지만 Groonga는 Mysql과 전혀 연관없이 독립적으로 기동하는 소프트웨어라서 Mysql에 익숙한 사용자를 위해 mGroonga 라는 플러그인을 함께 제공한다. 3.7.3 스핑크스 전문 검색 엔진스핑크스는 Mysql 서버와는 전혀 연관이 없이 자체적인 저장 공간을 가지고 별도의 프로세스로 작동하며, Mysql 서버를 통해 접근할 수 있는 인터페이스만 제공하는 형태의 스토리지 엔진이다. N-그램방식의 인덱싱과 UTF-8 언어를 지원하는것과 분산처리 기능이 상당히 뛰어나다는 것이 장점이다. 3.8 Mysql 로그 파일3.8.1 에러 로그 파일Mysql이 실행되는 도중에 발생하는 에러나 경고 메세지가 출력되는 로그 파일이다. 에러 로그 파일의 위치는 configure 파일에 “log_error” 라는 이름의 파라미터에 정의된 경로에 있는 파일이거나, 별도로 지정되지 않은 경우에는 데이터 디렉터리에 “.err” 확장자가 붙은 파일이다. 여러가지 메시지가 다양하게 출력되지만 다음에 소개되는 메시지를 가장 자주 보게 될 것이다. Mysql 이 시작하는 과정과 관련된 정보성 및 에러 메시지 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지 비정상적으로 종료된 커넥션 메시지 InnoDB의 모니터링 명령이나 상태 조회 명령의 결과 메시지 Mysql 종료 메시지 3.8.2 제너럴 쿼리 로그 파일쿼리 로그파일은 configure 파일의 “general-log” 라는 이름의 파라메터에 정의된 경로에 있는 파일이고 Mysql 5.1.12 이상의 버전에서는 “general_log_file” 이라는 이름의 파라메터에 정의된 경로에 있는 파일이다. 3.8.3 슬로우 쿼리 로그Mysql 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영중에 Mysql 서버의 전체적인 성능 저하를 검사하거나 또는 정기적인 점검을 위한 튜닝으로 나눌 수 있다. 전자의 경우에는 검토해야 할 대상 쿼리가 전부라서 모두 튜닝하면 되지만, 후자의 경우에는 어떤 쿼리가 문제의 쿼리인지 판단하기가 상당히 어렵다. 이런 경우에 서비스에서 사용되고 있는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는데 슬로우 쿼리 로그가 상당히 많은 도움이 된다. 슬로우 쿼리 로그 파일에는 configure 에서 정의한 시간(long_query_time) 이상의 시간이 소요된 쿼리가 모두 기록된다. 실제 소요된 시간을 기준으로 기록 여부를 판단하기 때문에 정상적으로 실행된 쿼리만 기록된다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍처 CH 3.4, CH 3.5, CH 3.6","slug":"Mysql-architecture3","date":"2017-07-08T13:22:33.000Z","updated":"2017-07-08T14:46:34.534Z","comments":true,"path":"2017/07/08/Mysql-architecture3/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture3/","excerpt":"","text":"3.4 Memory 스토리지 엔진 아키텍처Memory 스토리지 엔진은 Heap 스토리지 엔진 이라고도 하는데, 이름 그대로 데이터를 메모리에 저장하는 것이 특징이다. 데이터의 크기가 작고 아주 빠른 처리가 필요한 경우 적합한 엔진이다. 3.4.1 주의사항테이블의 최대 크기다른 스토리지 엔진을 이용한 테이블과는 달리 Memory 스토리지 엔진을 사용하는 테이블은 저장할 수 있는 데이터의 최대 용량이 정해져 있다. 최대 데이터의 크기는 max_heap_table_size 파라미터로 정의한다 고정 길이 칼럼만 지원Memory 테이블의 모든 칼럼은 항상 고정 길이로만 생성된다. 즉 varchar(100)와 같은 타입의 칼럼을 만들어도 char(100)과 동일하게 공간이 할당된다는 의미이다. 따라서 불필요하게 너무 큰 데이터 타입을 사용하지 않는 것이 좋다. Blob 이나 Text와 같은 LOB(Large Object) 타입은 지원하지 않음Memory 테이블은 기본적으로 해시 인덱스 사용InnoDB나 MyISAM 테이블을 생성할 때 별다른 내용을 명시하지 않으면 기본적으로 B-Tree 인덱스가 생성되지만 Memory 스토리지 엔진을 사용하면 해시 인덱스를 생성한다. 3.4.2 용도Memory 스토리지는 사실 Mysql 엔진이 쿼리를 처리하는 과정에서 임시로 생성되는 임시 테이블 용도로 자주 사용된다. 3.5 NDB 클러스터 스토리지 엔진NDB 클러스터는 “Network DataBase” 의 줄임말로 일반적으로 NDB 라 불리운다. NDB는 데이터의 분산이나 그로인한 성능 향상 보다는 가용성에 집중된 스토리지 엔진이다. 3.5.1 NDB 클러스터의 특성무공유 클러스터링NDB는 데이터를 저장하는 스토리지가 분산되어 관리되기 때문에 하나의 데이터 저장소가 작동을 멈추더라도 서비스에 영향을 미치지 않는다. 메모리 기반의 스토리지 엔진NDB는 클러스터 노드 간의 빠른 데이터 동기화를 위해 메모리를 사용한다. NDB 클러스터는 데이터 스토리지까지 분산하기 때문에 각 노드의 물리적 메모리를 모두 합친 것이 실제 저장 가능한 최대 용량이 된다. 자동화된 Fail-overNDB는 모든 구성 노드가 서로의 상태를 계속 체크하고 있기 때문에 특정 노드에 문제가 발생해도 다른 사용 가능한 노드가 그 역할을 이어받는 형태로 페일 오버가 가능하다. 분산된 데이터 저장소간의 동기 방식(Sync) 복제NDB에서 데이터 저장소는 분산되어 관리되는데, 각 데이터 저장소는 전체 데이터를 N등분해서 자신이 전담하는 파티션과 백업으로 보조 파티션을 구성한다. 각 데이터 저장소는 분산된 서로의 데이터를 동기화 해야 하는데 NDB는 비동기 방식이 아닌 동기 방식으로 서로의 데이터를 전달한다. 온라인 스키마 변경NDB는 테이블에 칼럼이나 인덱스를 추가하면서 동시에 Insert 나 Update와 같은 DML 쿼리를 처리할 수 있다. 이를 온라인 스키마 변경이라 하는데 사용하는 방법은 Alter table 이나 Create index 명령에 Online 키워드를 사용하면 된다. Online 키워드를 사용하지 않은 스키마 변경 쿼리(DDL)은 클러스터가 온라인 처리 유무를 판단하고 가능한 경우 온라인 방식으로 처리한다. NoSql네트워크 DBNDB는 내부적으로 데이터를 저장하고 읽기 위해 네트워크를 기반으로 작동한다. 이는 하나의 서버에서 모든 처리가 일어나는 다른 스토리지 엔진과는 상당히 다른 개념이다 3.5.2 NDB 클러스터의 아키텍처NDB 클러스터 노드의 종류 관리노드 관리노드는 실제 NDB가 정상 상태에서 서비스되는 도중에는 거의 하는 일이 없다. 관리노드는 NDB 클러스터의 전체적인 구조에 대한 정보를 다른 노드에게 전파하거나 각 노드의 장애 상황을 전파하는 역할을 담당한다. 데이터 노드 데이터 노드는 클러스터에 대한 전반적인 작업을 수행하는 노드다. 대표적으로는 데이터를 저장하는 스토리지를 관리하고 SQL 노드에서 오는 데이터 조작 요청을 모두 처리한다. 또한 SQL 노드가 아닌 API 노드의 요청도 처리한다. 기본적으로 데이터에 관련된 모든 요청을 데이터 노드가 처리한다고 이해하면 된다. SQL 노드 NDB에 접속해 데이ㅓ를 읽고 쓰는 방법은 Mysql 서버를 통해 Sql 문법으로 처리할 수도 있지만 자바나 C 같은 프로그래밍 언어를 이용해 클러스터의 데이터를 조작할 수도 있다. 후자의 방법은 NDB API를 이용하는 방법으로 API 노드라고 표현한다. 반면 SQL서버를 이용해 NDB에 접속하는 경우를 SQL 노드라고 한다. 데이터 노드 간의 파티션 관리NDB 클러스터는 데이터 노드가 손상되어도 서비스가 가능하도록 클러스터 데이터를 파티션해서 각 파티션을 최소 2개 이상의 데이터 노드에 복제해둔다. 또한 원활한 관리를 위해 데이터 노드를 노드 그룹으로 나누는데, 노드 그룹에는 반드시 1개 이상의 데이터 노드가 존재해야 하며, 노드 그룹에 속한 데이터 노드는 항상 동일한 데이터 파티션을 가진다. 3.5.3 클러스터 간의 복제 구성NDB 클러스터에도 Mysql의 복제를 적용할 수 있는데, 이런 경우는 특별히 클러스터간 복제라고 표현한다. 3.5.6 NDB 클러스터의 용도처음에 NDB는 이동통신 사용자의 로그인 정보를 저장하는데 있었는데, 가용성이 극대화된, 소위 세션 데이터 전용 데이터베이스를 만드는 것이 목적이었다. 지금도 세션 전용 데이터베이스로 많이 사용되고 있다. 3.6 TOKUDB 스토리지 엔진3.6.1 프랙탈 트리(Fractal Tree) 인덱스 지원B-Tree의 경우 계속되는 Insert, Update, Delete 작업으로 인해 인덱스 페이지 내에 사용되지 못하는 공간이 생기는데 이를 단편화라고 한다. 단편화 현상에 의해 동일한 레코드건수를 조회 하더라도 디스크에서 읽어야 할 인덱스의 숫자가 많아질 수 있고, 버퍼 풀과 같은 캐시영역의 공간도 많이 차지하게 된다. 이러한 현상은 범위 검색과 같은 작업에 비효율성을 발생시킨다. 프랙탈 트리 인덱스는 B-Tree의 단점을 보완한 새로운 형태의 인덱싱 알고리즘이며, 이 알고리즘을 사용한 TokuDB는 프랙탈 트리의 알고리즘 개발자가 설립한 회사에서 출시한 스토리지 엔진이다. 3.6.2 대용량 데이터와 빠른 Insert 처리위와 같은 프랙탈 트리를 사용함으로써 인덱스에 새로운 레코드를 추가하는 작업이 상당히 빨라진다. 3.6.3 트랜잭션 및 잠금 처리3.6.4 그 이외의 특징3.6.5 TokuDB의 주 용도 SNS 기반의 대용량 테이블(동시성을 크게 요하지 않는) 실시간 웹페이지 클릭 분석 웹 서버나 게임 서버의 로그 분석 고성능 웹 크롤링 데이터웨어 하우스","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍처 CH 3.2, CH 3.3","slug":"Mysql-architecture2","date":"2017-07-08T09:02:39.000Z","updated":"2017-07-08T14:46:25.772Z","comments":true,"path":"2017/07/08/Mysql-architecture2/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture2/","excerpt":"","text":"3.2 InnoDB 스토리지 엔진 아키텍처3.2.1 InnoDB 스토리지 엔진의 특성PK에 의한 클러스터링InnoDB의 모든 데이터 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉 PK값의 순서대로 디스크에 저장된다는 의미이며, 이로 인해 PK에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다. 잠금이 필요없는 일관된 읽기InnoDB는 MVCC(Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 외래 키 지원InnoDB에서는 외래키를 지원하지만 실무에서는 여러가지 제약때문에 잘 사용하지 않다. 하지만 데이터베이스의 좋은 가이드 역할로 사용이 가능하다. 자동 데드락 감지InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 rollback 이 가장 용이한 트랜잭션을 자동적으로 강제 종료해 버린다. 자동화된 장애 복구오라클의 아키텍처 적용3.2.2 InnoDB 버퍼 풀InnoDB 스토리지 엔젠에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. MyISAM 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 InnoDB의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리하고 있는 것이다. 3.2.3 Undo 로그언두 영역은 update, delete와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다. 언두의 데이터는 크게 두가지 용도로 사용되는데, 첫 번째가 트랜잭션의 롤백 대비용, 두 번째는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 사용된다. 트랜잭션의 격리 수준이라는 개념이 있는데, 이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때, 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준이다. 3.2.4 Insert BufferRDBMS에서 레코드가 insert 되거나 update 될때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다. 그런 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다. InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로 부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 인서트 버퍼(Insert Buffer) 라고 한다. 3.2.5 Redo 로그 및 로그 버퍼쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다. 하지만 이런 작업은 랜덤하게 디스크에 기록해야 하므로 디스크를 바쁘게 만드는 작업이다. 그래서 대부분의 DBMS에는 변경된 데이터를 버퍼링해 두기 위해 InnoDB 버퍼 풀과 같은 장치가 포함되어 있다. 하지만 이 장치만으로는 ACID를 보장할 수 없는데 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 이를 리두 로그 라고 한다. 하지만 사용량이 많은 DBMS 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가 되는데, 이러한 부분을 보완하기 위한 로그 버퍼링이 존재하는데 이 로그 버퍼링에 사용되는 공간이 로그 버퍼 이다. 3.2.6 MVCC(Multi Version Concurrency Control)MVCC는 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB에서는 언두 로그를 이용해 이 기능을 구현한다. update 문장이 실행될 때 기존의 데이터는 언두 로그에 기록되며 새로운 데이터는 InnoDB 버퍼 풀에 기록된다. 즉 하나의 레코드에 대해 두가지 버전의 데이터가 있으며 select문을 이용해 조회를 할 경우 보여지는 데이터는 격리수준에 따라 다르다. 최종적으로 commit 이 되면 레코드의 테이터를 바꾸고, rollback 을 하면 언두 영역에 있는 데이터를 버퍼 풀로 가져온다. 즉 커밋이 된다고 언두 영역의 데이터가 바로 삭제되는게 아니다. 이 언두 영역을 필요로 하는 트랜잭션이 더는 필요 없을 때 비로소 삭제된다. 3.2.7 잠금이 없는 일관된 읽기특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 select 작업을 방해하지 않는다. 이를 잠금이 없는 일관된 읽기 라고 표현하며 InnoDB에서는 언두 로그를 사용하여 구현한다. 3.3 MyISAM 스토리지 엔진 아키텍처3.3.1 키 캐시InnoDB의 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 키 캐시다. 하지만 키 캐시는 인덱스만 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다. 3.3.2 운영체제의 캐시 및 버퍼MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다. 하지만 MyISAM 테이블의 데이터는 디스크로부터의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 그래서 운영체제의 디스크 읽기/쓰기 작업으로 요청될 수 밖에 없다. 운영체제의 캐시 기능은 InnoDB 같이 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지는 못하지만 그래도 없는 것 보다는 낫다. 운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"3. Mysql 아키텍쳐 CH 3.1","slug":"Mysql-architecture","date":"2017-07-08T07:37:31.000Z","updated":"2017-07-08T14:46:39.585Z","comments":true,"path":"2017/07/08/Mysql-architecture/","link":"","permalink":"https://jumpegg.github.io/2017/07/08/Mysql-architecture/","excerpt":"","text":"3.1.1 Mysql 전체적인 구조Mysql 은 크게 Mysql엔진과 스토리지 엔진으로 구분해 볼 수 있다. Mysql 엔진Mysql 엔진은 클라이언트로 부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러 와 SQL 파서 및 전처리기, 그리고 쿼리의 최적화된 실행을 위한 옵티마이저 가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함되 있다. 스토리지 엔진스토리지 엔진은 실질적으로 데이터를 디스크 스토리지에 저장하거나 디스크로 부터 데이터를 읽어오는 부분을 전담한다. Mysql 서버에서 Mysql엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다. 핸들러 APIMysql 엔진의 쿼리 실행기에서 데이터를 읽기/쓰기 작업을 할때 스토리지에 읽기/쓰기 작업을 요청하는데, 이런 요청작업을 핸들러(Handler) 요청이라 하고, 여기에 사용되는 API를 핸들러API라고 한다. 3.1.2 Mysql 스레딩 구조Mysql은 프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 포그라운드(Foreground)와 백그라운드(Background)로 구분할 수 있다. 포그라운드 스레드포그라운드 스레드는 최소한 Mysql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다. 포그라운드 스레드는 데이터를 Mysql의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리한다. 백그라운드 스레드MyISAM과는 다르게 InnoDB에서는 여러가지 작업이 백그라운드로 처리된다. 그중 가장 중요한것이 로그 스레드(Log thread) 와 버퍼의 데이터를 디스크로 내려 쓰는 작업을 처리하는 쓰기 스레드(Write thread) 이다. 3.1.3 메모리 할당 구조Mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.두 영역의 차이는 Mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지로 구분할 수 있다. 글로벌 메모리 영역일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다. 로컬 메모리 영역세션 메모리 영역이라고도 표현하며, 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 로컬메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다. 3.1.4 플러그인 스토리지 엔진 모델Mysql의 독특한 구조 중 대표적인 것이 바로 플러그인 모델이다. 쿼리 실행과정에서 데이터 읽기/쓰기 작업이 스토리지 엔진에 의해 처리된다. 복잡한 처리, 예를 들면 group by 나 order by 는 Mysql 의 쿼리 실행기에서 처리가 된다. 여기서 중요한점은 ‘하나의 쿼리 작업’ 은 ‘여러가지 하위 작업’ 으로 나뉘는데 각각의 하위 작업이 어디에서 처리되는지 구분할 줄 알아야 한다.스토리지 엔진은 대표적으로 MyISAM과 InnoDB가 있다. 123mysql&gt; show engines; -- 이 명령어를 통해 지원되는 엔진 확인가능...mysql&gt; show plugins; -- 플러그인 확인 명령어 3.1.5 쿼리 실행구조파서파서는 쿼리문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다. 전처리기파서에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 옵티마이저쿼리문장을 저렴한 비용으로 가장 빠르게 처리할 지 결정하는 역할을 담당한다. 실행 엔진만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다. 핸들러(스토리지 엔진)Mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다. 3.1.6 복제(Replication)데이터가 갈수록 대용량화돼 가는 것을 생각하면 확장성(Scalability)은 DBMS에서 아주 중요한 요소인데, Mysql에서 확장성을 위한 일반적인 기술로는 복제(Replication)를 들어볼 수 있다. 복제는 2대 이상의 Mysql 서버가 동일한 데이터를 담도록 실시간 동기화하는 기술이다. 서버의 역할에 따라서 master 와 slave 로 나눌 수 있다. 복제 주의사항 슬레이브는 하나의 마스터만 설정 가능 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 일기 전용으로 설정 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합 복제가 불필요한 경우에는 바이너리 로그 중지 바이너리 로그와 트랜잭션 격리 수준(Isolation level) 3.1.7 쿼리 캐시쿼리 캐시는 타 DBMS에는 없는 Mysql의 독특한 기능이다. 여러가지 복잡한 처리 절차와 꽤 큰 비용을 들여 실행된 결과를 쿼리 캐시에 담아 두고, 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾아 바로 결과를 준다. 쿼리 캐시는 SQL 문장의 결과는 메모리에 캐시해 두는 기능이다. 쿼리 캐시의 구조는 간단한 키와 값의 쌍으로 관리되는 맵(Map)과 같은 데이터 구조로 구현되 있다. 여기서 키는 쿼리문장 , 값은 쿼리 실행결과 형태로 저장되어 있다. 쿼리 캐시를 사용할 경우 캐시에 있는 쿼리 결과를 넘기기 전에 다음과 같은 확인절차가 필요하다. 요청된 쿼리 문장이 쿼리 캐시에 존재하는가? 해당 사용자가 그 결과를 볼 수 있는 권한을 가지는가? 트랜젝션 내에서 실행된 쿼리인 경우, 그 결과가 가시범위 내의 트랜젝션에서 만들어진 결과인가? 쿼리에 사용된 기능이 캐시되도 동일한 결과를 보장할 수 있는가? Current_date, sysdate, rand 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가? 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가? 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가? 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가? 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가? 이런 제약사항들에도 불구하고 쿼리캐시는 훌륭한 기능이다. 다음을 통해 쿼리캐시 관련 데이터들을 볼 수 있다. 123mysql&gt; show global status like 'Qcache%'; -- 쿼리캐시 관련 데이터....mysql&gt; show global status like 'Com_select'; Qcache_hits는 쿼리캐시로 처리된 select 쿼리의 수를 의미하며, Com_select 쿼리캐시에서 결과를 찾지 못해서 직접 실행한 횟수이다. 즉 Com_select 와 Qcache_hits를 더하면 Mysql 서버로 요청된 모든 select 문장의 총 합이 되는 것이다. 쿼리 캐시 히트율(%) = Qcache_hits/ (Qcache_hits + Com_select) * 100 보통 쿼리캐시 히트율이 20% 이상이면 쿼리캐시를 사용하는 것이 좋다고 한다. 하지만 히트율이 1% 라도 아주 큰 자원을 소모하는 쿼리의 경우 쿼리캐시를 사용하는 것이 좋다.","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/categories/Mysql/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://jumpegg.github.io/tags/Mysql/"}]},{"title":"Ionic 간단한 nav 개념잡기","slug":"ionic-nav","date":"2017-07-07T14:37:10.000Z","updated":"2017-07-09T05:48:34.603Z","comments":true,"path":"2017/07/07/ionic-nav/","link":"","permalink":"https://jumpegg.github.io/2017/07/07/ionic-nav/","excerpt":"","text":"IONIC 간단한 nav 개념잡기기본적인 페이지 이동ionic 은 router 의 개념이 stack을 통해 view 를 push/pop 하는 형식이다.(이것은 한글인가 영어인가….) 1234567891011import &#123;NavController&#125; from 'ionic-angular';.....@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125;&#125; 여기서 클래스 이름 그대로 NavController 가 네비게이션 컨트롤러 역할을 한다. 페이지를 넘기고 싶다면 push 를 이용해서 이동하고 싶은 페이지의 컴포넌트를 입력시키면 된다. 1234567891011121314151617import &#123;NavController&#125; from 'ionic-angular';.....import &#123;SecondPage&#125; from '../Component/SecondPage/SecondPage';@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125; moveToSecond()&#123; this.navCtrl.push(SecondPage); //push 를 이용한 페이지 이동 &#125;&#125; 페이지간 데이터 전송페이지간 데이터를 전송하고 싶다면 push에 파라메터로 넘기고싶은 데이터의 Object를 파라메터로 넘겨주고, 받는 페이지에서는 navParams.get() 을 이용해서 받으면 된다. 파라메터를 넘기는 IndexPage 1234567891011121314151617import &#123;NavController&#125; from 'ionic-angular';.....import &#123;SecondPage&#125; from '../Component/SecondPage/SecondPage';@Component(&#123; templateUrl: 'yourIndex.html';&#125;)export class IndexPage&#123; constructor( public navCtrl:NavController)&#123; &#125; moveToSecond()&#123; this.navCtrl.push(SecondPage,&#123;msg: \"It's work!!\"&#125;); // 컴포넌트에 msg 라는 파라메터 넘김 &#125;&#125; 파라메터를 받는 SecondPage 12345678910111213141516import &#123;NavController, NavParams&#125; from 'ionic-angular';....@Component(&#123; templateUrl: 'yourSecond.html';&#125;)export class SecondPage&#123; constructor( public navCtrl:NavController, public navParams:NavParams)&#123; &#125; ionViewDidLoad() &#123; console.log(this.navParams.get('msg')); // 파라메터에 접근 &#125;&#125; rootPage 설정페이지가 이동을 하면 새로 root 페이지를 설정해줘야 할 때가 있다. 예를들면 로그인 이후 화면? 같은것을 예로 들 수 있다. setRoot()를 이용하면 root 페이지를 바꿀 수 있다. 1234567891011121314151617import &#123;NavController, NavParams&#125; from 'ionic-angular';....@Component(&#123; templateUrl: 'yourSecond.html';&#125;)export class SecondPage&#123; constructor( public navCtrl:NavController, public navParams:NavParams)&#123; &#125; ionViewDidLoad() &#123; console.log(this.navParams.get('msg')); // 파라메터에 접근 this.navCtrl.setRoot(SecondPage); // SecondPage로 root를 바꾼다 &#125;&#125; setRoot() 사용시 주의점은 root를 바꿔주면서 해당 페이지로 이동시키기 때문에 setRoot() 를 사용하는 지점을 잘 생각해야 한다. 실수로 자기 자신을 루트로 잡아봤는데 무한루프가 도는 것을 볼 수 있었다. 참조 사이트http://www.joshmorony.com/a-simple-guide-to-navigation-in-ionic-2/고 투 더 멘토","categories":[{"name":"ionic2","slug":"ionic2","permalink":"https://jumpegg.github.io/categories/ionic2/"}],"tags":[{"name":"ionic2 nav","slug":"ionic2-nav","permalink":"https://jumpegg.github.io/tags/ionic2-nav/"}]},{"title":"Hexo 를 시작해보자","slug":"start","date":"2017-07-06T09:15:19.000Z","updated":"2017-07-06T09:31:29.888Z","comments":true,"path":"2017/07/06/start/","link":"","permalink":"https://jumpegg.github.io/2017/07/06/start/","excerpt":"","text":"hexo 가 있는건 진작 알고 있었는데, 혼자 하는 프로젝트가 어느정도 끝나가면서 사용했던 개념들을 기록 할 공간이 필요했다. 그래서 이번에 기록 할 겸 hexo도 사용해볼겸 해서 블로그를 시작하게 되었다. 우선 hexo 를 시작해보자 Hexo 를 시작해보자hexo 설치1$ npm install -g hexo-cli cli 환경이 익숙치 않은 사람들에게는 낯설겠지만 hexo 는 cli 환경에서 페이지를 생성하고 markdown 문법을 사용해서 내용을 구성한다. 아무튼, 명령어를 치면 이제 hexo 명령어 들을 사용할 수 있다. hexo init1$ hexo init [폴더명] init 명령어를 사용하면 해당 폴더에 hexo를 사용하기 위한 기본 구조와 파일들이 생성된다 이제 생성한 폴더에 들어가서 hexo 명령어들을 이용해서 작업하면 된다. hexo new1$ hexo new [포스트명] 폴더 안으로 들어가서 new 명령어를 실행하면 [포스트명] 으로 source/_posts/ 폴더안에 파일이 생성된다. 이 파일들이 우리가 만드는 컨텐츠가 된다.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jumpegg.github.io/categories/Hexo/"}],"tags":[]}]}