<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wonny&#39;s note</title>
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://jumpegg.github.io/"/>
  <updated>2017-07-15T04:25:45.876Z</updated>
  <id>https://jumpegg.github.io/</id>
  
  <author>
    <name>Wonny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CH 4 트랜잭션(4.4, 4.5)</title>
    <link href="https://jumpegg.github.io/2017/07/15/mysql-transection3/"/>
    <id>https://jumpegg.github.io/2017/07/15/mysql-transection3/</id>
    <published>2017-07-15T01:29:33.000Z</published>
    <updated>2017-07-15T04:25:45.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-4-InnoDB-스토리지-엔진의-잠금"><a href="#4-4-InnoDB-스토리지-엔진의-잠금" class="headerlink" title="4.4 InnoDB 스토리지 엔진의 잠금"></a>4.4 InnoDB 스토리지 엔진의 잠금</h2><p>InnoDb 스토리지 엔진은 MYSQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.</p>
<h3 id="4-4-1-InnoDB의-잠금-방식"><a href="#4-4-1-InnoDB의-잠금-방식" class="headerlink" title="4.4.1 InnoDB의 잠금 방식"></a>4.4.1 InnoDB의 잠금 방식</h3><ul>
<li><p>비관적 잠금<br>현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식</p>
</li>
<li><p>낙관적 잠금</p>
</li>
</ul>
<p>낙관적 잠금에서는 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고 가정한다. 그래서 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK처리 하는 방식을 의미한다.</p>
<h3 id="4-4-2-InnoDB의-잠금의-종류"><a href="#4-4-2-InnoDB의-잠금의-종류" class="headerlink" title="4.4.2 InnoDB의 잠금의 종류"></a>4.4.2 InnoDB의 잠금의 종류</h3><ul>
<li>레코드 락(Record lock, Record only lock)</li>
</ul>
<p>레코드 자체만을 잠그는 것을 레코드 락 이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다. 한가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다. 만약 인덱스가 하나도 없는 테이블이라 하더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.</p>
<ul>
<li>갭 락(Gap lock)</li>
</ul>
<p>다른 DBMS와의 또 다른 차이는 바로 갭 락이다. 갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다. 갭 락의 역할은 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어하는 것이다.</p>
<ul>
<li>넥스트 키 락(Next key lock)</li>
</ul>
<p>레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다. </p>
<ul>
<li>자동 증가 락(Auto increment lock)</li>
</ul>
<p>Auto_increment 칼럼이 사용된 테이블에 동시에 여러 레코드가 insert 되는 경우, 저장되는 각 레고드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다. InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 Auto_increment 락이라고 하는 테이블의 수준의 잠금을 사용한다.</p>
<h3 id="4-4-3-인덱스와-잠금"><a href="#4-4-3-인덱스와-잠금" class="headerlink" title="4.4.3 인덱스와 잠금"></a>4.4.3 인덱스와 잠금</h3><p>InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있다. 레코드 락은 레코드의 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.</p>
<p>하나의 테이블에 update 문장이 실행되면 Mysql의 InnoDB는 인덱스로 사용된 컬럼의 값과 동일한 레코드 들에 락을 건다. 만약 인덱스가 없다면 해당 테이블의 레코드에 모두 락을 건다.</p>
<h3 id="4-4-4-트랜잭션-격리-수준과-잠금"><a href="#4-4-4-트랜잭션-격리-수준과-잠금" class="headerlink" title="4.4.4 트랜잭션 격리 수준과 잠금"></a>4.4.4 트랜잭션 격리 수준과 잠금</h3><p>이러한 불필요한 레코드의 잠금 현상은 InnoDB의 넥스트 키 락 때문에 발생하는 것이다. 하지만 InnoDB에서 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문이다. 레코드 기반의 바이너리 로그를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다.</p>
<ul>
<li><p>Mysql 5.0<br>innodb_locks_unsafe_for_binlog = 1<br><br>트랜잭션 격리수준을 READ-COMMIT 로 설정</p>
</li>
<li><p>Mysql 5.1 이상</p>
</li>
</ul>
<ol>
<li>바이너리 로그를 비활성화</li>
<li>레코드 기반의 바이너리 로그 사용 : innodb_locks_unsafe_for_binlog = 1</li>
</ol>
<h3 id="4-4-5-레코드-수준의-잠금-확인-및-해제"><a href="#4-4-5-레코드-수준의-잠금-확인-및-해제" class="headerlink" title="4.4.5 레코드 수준의 잠금 확인 및 해제"></a>4.4.5 레코드 수준의 잠금 확인 및 해제</h3><p>InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 복잡하다.<br>(복잡해서 요약이 안됨)</p>
<h2 id="4-5-Mysql의-격리-수준"><a href="#4-5-Mysql의-격리-수준" class="headerlink" title="4.5 Mysql의 격리 수준"></a>4.5 Mysql의 격리 수준</h2><p>트랜잭션의 격리 수준이란 동시에 여러 트랜잭션이 처리될 때, 득정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 격리 수준은 크게 READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALIZABLE 의 4가지로 나뉜다.</p>
<p>데이터베이스의 격리수준을 이야기 하면 항상 언급되는 것은 부정합이다. 3가지 부정합 문제가 있으며 각각의 격리수준에 따른 부정합 문제는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>격리수준</th>
<th>DIRTY READ</th>
<th>NON-REPEATABLE READ</th>
<th>PHANTOM READ</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>발생</td>
<td>발생</td>
<td>발생</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>발생하지 않음</td>
<td>발생</td>
<td>발생</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>발생하지 않음</td>
<td>발생하지 않음</td>
<td>발생(InnoDB는 발생하지 않음)</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>발생하지 않음</td>
<td>발생하지 않음</td>
<td>발생하지 않음</td>
</tr>
</tbody>
</table>
<h3 id="4-5-1-READ-UNCOMMITTED"><a href="#4-5-1-READ-UNCOMMITTED" class="headerlink" title="4.5.1 READ UNCOMMITTED"></a>4.5.1 READ UNCOMMITTED</h3><p>READ UNCOMMITTED 격리 수준에서는 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다. 이때 다른 트랜잭션에는 변경된 레코드가 반영되지 않는 현상을 Dirty read 라고 한다. Dirty read는 사용자와 개발자를 혼란스럽게 한다.</p>
<h3 id="4-5-2-READ-COMMITTED"><a href="#4-5-2-READ-COMMITTED" class="headerlink" title="4.5.2 READ COMMITTED"></a>4.5.2 READ COMMITTED</h3><p>READ COMMITTED는 오라클 DBMS에서 기본적으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. Dirty read 같은 현상은 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 Commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다.</p>
<p>READ COMMITTED는 Non-repeatable read 부정합의 문제가 있다. 데이터 변경 후 커밋 이전에 조회문을 날렸을 때와 커밋 이후에 조회문을 날렸을 때 가져오는 데이터가 다른 경우, 하나의 트랜잭션에서 똑같은 select 쿼리를 실행했을 때 항상 같은 결과를 가져와야 하는데 위의 경우는 다른 결과를 가져오게 된다.</p>
<p>이러한 부정합 현상은 일반적인 웹에서는 문제는 없지만 하나의 트랜잭션에서 데이터를 여러번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.</p>
<h3 id="4-5-3-REPEATABLE-READ"><a href="#4-5-3-REPEATABLE-READ" class="headerlink" title="4.5.3 REPEATABLE READ"></a>4.5.3 REPEATABLE READ</h3><p>REPEATABLE READ는 Mysql의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다. 바이너리 로그를 가진 Mysql의 장비에서는 최소 Repeatable read 격리 수준 이상을 사용해야 한다. InnoDB에서는 MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.</p>
<h3 id="4-5-4-SERIALIZABLE"><a href="#4-5-4-SERIALIZABLE" class="headerlink" title="4.5.4. SERIALIZABLE"></a>4.5.4. SERIALIZABLE</h3><p>가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다. 또한 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. 트랜잭션의 격리수준이 SERIALIZABLE 로 설정되면 일기 작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-4-InnoDB-스토리지-엔진의-잠금&quot;&gt;&lt;a href=&quot;#4-4-InnoDB-스토리지-엔진의-잠금&quot; class=&quot;headerlink&quot; title=&quot;4.4 InnoDB 스토리지 엔진의 잠금&quot;&gt;&lt;/a&gt;4.4 InnoDB 스토리지 엔진의 
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="transection" scheme="https://jumpegg.github.io/tags/transection/"/>
    
  </entry>
  
  <entry>
    <title>ionic root nav 문제해결</title>
    <link href="https://jumpegg.github.io/2017/07/13/ionic-problem-01/"/>
    <id>https://jumpegg.github.io/2017/07/13/ionic-problem-01/</id>
    <published>2017-07-13T09:09:16.000Z</published>
    <updated>2017-07-13T09:39:25.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ionic-root-문제"><a href="#Ionic-root-문제" class="headerlink" title="Ionic root 문제"></a>Ionic root 문제</h3><p>ionic을 사용하다 보면 페이지 컨트롤을 위해서 자연적으로 NavController를 사용하게 되는데, 정확히 파악하지 않은 상태에서 NavCtrl을 사용하다 보니 내가 생각했던 구조대로 앱이 만들어지지 않고 있다는 것을 깨닫게 되었다.</p>
<h4 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h4><p>우선 내가 의도한 구조는 이렇다<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app&lt;Nav&gt;&#123;</div><div class="line">	LoginPage,</div><div class="line">	UserPage&lt;Nav&gt;:[</div><div class="line">		page1,</div><div class="line">		page2,</div><div class="line">		page3,</div><div class="line">		.....</div><div class="line">	],</div><div class="line">	StudyPage&lt;Nav&gt;:[</div><div class="line">		page1,</div><div class="line">		page2,</div><div class="line">		page3,</div><div class="line">		.....</div><div class="line">	],</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>하지만 내가 만든 구조는 이렇게 되어있었다.<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app&lt;Nav&gt;&#123;</div><div class="line">	LoginPage,</div><div class="line">	UserPage&lt;Nav&gt;:[</div><div class="line">		page1,</div><div class="line">		page2,</div><div class="line">		page3,</div><div class="line">		.....</div><div class="line">		StudyPage&lt;Nav&gt;:[</div><div class="line">			page1,</div><div class="line">			page2,</div><div class="line">			page3,</div><div class="line">			.....</div><div class="line">		]</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>상황이 심각하다.</p>
<h4 id="문제인식"><a href="#문제인식" class="headerlink" title="문제인식"></a>문제인식</h4><p>구조가 잘못되고 있다는것을 인식한 것은 UserPage에서 생성한 css 가 StudyPage에 영향을 미치고 있는걸 보고 알게 되었다. 기본적으로 ionic은 각 페이지 별로 css 정의를 할 수 있고, 자식 컴포넌트가 아니면 css간 영향이 없다.</p>
<h4 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h4><p>공식 홈페이지나 구글링을 통해 얻을 수 있는 Tutorial 을 따라하다 보면 navCtrl.push(), navCtrl.pop(), navCtrl.setRoot() 에 관한 설명은 잘 되어있으나 그 이상은 설명되어 있지 않으며 여기서 필자의 경우엔 setRoot() 의 작동방식을 착각한 것이 원인이었다.</p>
<h4 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h4><p>여기 저기에서 사용한 setRoot()는 해당 컴포넌트에 ion-nav 를 사용하지 않으면 부모 컴포넌트의 ion-nav 를 바꿔주었지만, 컴포넌트에 ion-nav 가 있는 경우 해당 컴포넌트의 ion-nav를 바꿔준다. 그래서 최상단의 navCtrl을 가져오기 위해선 App을 가져와야 한다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; App, NavCtroller, NavParams&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">....</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	selector: <span class="string">'your-selector'</span>,</div><div class="line">	templateUrl: <span class="string">'your-template.html'</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> YourPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl: NavController,</div><div class="line">		<span class="keyword">public</span> navParams: NavParams,</div><div class="line">		<span class="keyword">public</span> appCtrl: App</div><div class="line">	)&#123;&#125;</div><div class="line">	...........</div><div class="line">	moveToPage()&#123;</div><div class="line">		<span class="comment">// getRootNav()는 최상단의 nav를 가져온다.</span></div><div class="line">		<span class="keyword">this</span>.appCtrl.getRootNav().setRoot(NextPage);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h4><p><a href="https://stackoverflow.com/questions/38879674/how-to-access-parent-navcontroller-ionic-2" target="_blank" rel="external">stack overflow</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Ionic-root-문제&quot;&gt;&lt;a href=&quot;#Ionic-root-문제&quot; class=&quot;headerlink&quot; title=&quot;Ionic root 문제&quot;&gt;&lt;/a&gt;Ionic root 문제&lt;/h3&gt;&lt;p&gt;ionic을 사용하다 보면 페이지 컨트롤을 위해
    
    </summary>
    
      <category term="문제해결" scheme="https://jumpegg.github.io/categories/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/"/>
    
    
      <category term="ionic-root" scheme="https://jumpegg.github.io/tags/ionic-root/"/>
    
  </entry>
  
  <entry>
    <title>ionic-menu</title>
    <link href="https://jumpegg.github.io/2017/07/12/ionic-menu/"/>
    <id>https://jumpegg.github.io/2017/07/12/ionic-menu/</id>
    <published>2017-07-12T08:59:02.000Z</published>
    <updated>2017-07-12T09:12:08.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IONIC-Menu-사용법"><a href="#IONIC-Menu-사용법" class="headerlink" title="IONIC Menu 사용법"></a>IONIC Menu 사용법</h2><h3 id="ionic-menu-사용"><a href="#ionic-menu-사용" class="headerlink" title="ionic menu 사용"></a>ionic menu 사용</h3><p>ion-menu 는 사이드 메뉴를 만드는데 사용된다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 템플릿 사이드 코드 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ion-menu</span> [<span class="attr">content</span>]=<span class="string">"mycontent"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">ion-content</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ion-list</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>some menu content, could be list items<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ion-list</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">ion-content</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ion-menu</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ion-nav</span> #<span class="attr">mycontent</span> [<span class="attr">root</span>]=<span class="string">"rootPage"</span>&gt;</span><span class="tag">&lt;/<span class="name">ion-nav</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ul>
<li>사이드 메뉴를 열 수 있는 버튼 생성<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">menuToggle</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">ion-icon</span> <span class="attr">name</span>=<span class="string">"menu"</span>&gt;</span><span class="tag">&lt;/<span class="name">ion-icon</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</div><div class="line"><span class="keyword">import</span> &#123; MenuController &#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;...&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyPage &#123;</div><div class="line"></div><div class="line"> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> menuCtrl: MenuController</span>) &#123;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> openMenu() &#123;</div><div class="line">   <span class="keyword">this</span>.menuCtrl.open();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> closeMenu() &#123;</div><div class="line">   <span class="keyword">this</span>.menuCtrl.close();</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> toggleMenu() &#123;</div><div class="line">   <span class="keyword">this</span>.menuCtrl.toggle();</div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IONIC-Menu-사용법&quot;&gt;&lt;a href=&quot;#IONIC-Menu-사용법&quot; class=&quot;headerlink&quot; title=&quot;IONIC Menu 사용법&quot;&gt;&lt;/a&gt;IONIC Menu 사용법&lt;/h2&gt;&lt;h3 id=&quot;ionic-menu-사용&quot;&gt;&lt;a
    
    </summary>
    
      <category term="ionic2" scheme="https://jumpegg.github.io/categories/ionic2/"/>
    
    
      <category term="ionic2-menu" scheme="https://jumpegg.github.io/tags/ionic2-menu/"/>
    
  </entry>
  
  <entry>
    <title>CH 4 트랜잭션(4.2, 4.3)</title>
    <link href="https://jumpegg.github.io/2017/07/12/mysql-transection2/"/>
    <id>https://jumpegg.github.io/2017/07/12/mysql-transection2/</id>
    <published>2017-07-12T05:45:19.000Z</published>
    <updated>2017-07-15T01:30:21.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-2-Mysql-엔진의-잠금"><a href="#4-2-Mysql-엔진의-잠금" class="headerlink" title="4.2 Mysql 엔진의 잠금"></a>4.2 Mysql 엔진의 잠금</h2><p>Mysql 에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 Mysql 엔진 레벨로 나눠볼 수 있다. Mysql 엔진은 Mysql 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 되는데, Mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.</p>
<h3 id="4-2-1-글로벌-락-Global-Lock"><a href="#4-2-1-글로벌-락-Global-Lock" class="headerlink" title="4.2.1 글로벌 락 (Global Lock)"></a>4.2.1 글로벌 락 (Global Lock)</h3><p>글로벌락은 “flush tables with read lock” 명령으로만 획득할 수 있으며, Mysql에서 제공하는 잠금 가운데 가장 범위가 크다. 글로벌 락이 영향을 미치는 범위는 Mysql 서버 전체이며, 작업 대상 테이블이나 데이터베이스가 다르다 하더라도 동일하게 영향을 미친다.</p>
<h3 id="4-2-2-테이블-락-Table-Lock"><a href="#4-2-2-테이블-락-Table-Lock" class="headerlink" title="4.2.2 테이블 락 (Table Lock)"></a>4.2.2 테이블 락 (Table Lock)</h3><p>개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 명시적으로는 “lock tables table_name [READ | WRITE]” 명령으로 특정 테이블의 락을 획득할 수 있다. 테이블 락은 MyISAM뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다. 명시적으로 획득한 잠금은 “Unlock Tables” 명령으로 잠금을 반납(해제) 할 수 있다.</p>
<h3 id="4-2-3-유저-락-User-Lock"><a href="#4-2-3-유저-락-User-Lock" class="headerlink" title="4.2.3 유저 락 (User Lock)"></a>4.2.3 유저 락 (User Lock)</h3><p>Get_lock() 함수를 이용해 임의로 잠금을 설정할 수 있다. 이 잠금의 특징은 대상이 테이블이나 레코드 또는 Auto_increment 와 같은 데이터베이스 객체가 아니라는 것이다. 유저락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다. 여러 클라이언트가 상호 동기화를 처리해야 할때 데이터베이스의 유저 락을 이용하면 쉽게 해결할 수 있다.</p>
<p>또한 유저락은 많은 레코드를 한번에 변경해야 하는 트랜잭션의 경우에 유용하게 사용할 수 있다. 배치 프로그램처럼 한번에 많은 레코드를 변경하는 경우 데드락의 원인이 되곤 한다. 이때 동일한 데이터를 변경하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.</p>
<h3 id="4-2-4-네임-락-Name-Lock"><a href="#4-2-4-네임-락-Name-Lock" class="headerlink" title="4.2.4. 네임 락 (Name Lock)"></a>4.2.4. 네임 락 (Name Lock)</h3><p>데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금이다. 네임 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 “Rename table tab_a To tab_b” 같은 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다. </p>
<h2 id="4-3-MyISAM-과-MEMORY-스토리지-엔진의-잠금"><a href="#4-3-MyISAM-과-MEMORY-스토리지-엔진의-잠금" class="headerlink" title="4.3 MyISAM 과 MEMORY 스토리지 엔진의 잠금"></a>4.3 MyISAM 과 MEMORY 스토리지 엔진의 잠금</h2><p>MyISAM 이나 MEMORY 스토리지 엔진은 자체적인 잠금을 가지지 않고 MYSQL 엔진에서 제공하는 테이블 락을 그대로 사용한다. 그리고 MyISAM 이나 MEMORY 스토리지 엔진에서는 쿼리 단위로 필요한 잠금을 한꺼번에 요청해서 획득하기 때문에 데드락이 발생할 수 없다. </p>
<h3 id="4-3-1-잠금-획득"><a href="#4-3-1-잠금-획득" class="headerlink" title="4.3.1 잠금 획득"></a>4.3.1 잠금 획득</h3><ul>
<li>읽기 잠금<br>테이블에 쓰기 잠금이 걸려 있지 않으면 바로 일기 잠금을 획득하고 읽기 작업을 시작할 수 있다.</li>
<li>쓰기 잠금<br>테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금을 획득할 수 있고, 그렇지 않다면 다른 잠금이 해제될 때까지 대기해야 한다.</li>
</ul>
<h3 id="4-3-2-잠금-튜닝"><a href="#4-3-2-잠금-튜닝" class="headerlink" title="4.3.2 잠금 튜닝"></a>4.3.2 잠금 튜닝</h3><p>테이블 락에 대한 작업 상황은 MYSQL 의 상태 변수를 통해 확인할 수 있다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show status like 'Table%';</div><div class="line"></div><div class="line">+-----------------------+---------+</div><div class="line">| Variable_name         | Value   |</div><div class="line">+-----------------------+---------+</div><div class="line">| Table_locks_immediate | 1551552 |</div><div class="line">| Table_locks_waited    | 15324   |</div><div class="line">+-----------------------+---------+</div></pre></td></tr></table></figure>
<p>Table_locks_immediate 는 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수이며, Table_locks_waited 는 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장하고 있다.</p>
<blockquote>
<p>잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_immediate + Table_locks_waited) * 100;</p>
</blockquote>
<p>위의 수치들을 대입해보면 약 1.31% 의 수치를 얻을 수 있으며, 이는 100개의 쿼리중 1개는 잠금 대기를 겪고 있다는 것을 알 수 있다.</p>
<h3 id="4-3-3-테이블-수준의-잠금-확인-및-해제"><a href="#4-3-3-테이블-수준의-잠금-확인-및-해제" class="headerlink" title="4.3.3 테이블 수준의 잠금 확인 및 해제"></a>4.3.3 테이블 수준의 잠금 확인 및 해제</h3><p>MYISAM 이나 MEMORY 등과 같은 스토리지 엔진을 사용하는 테이블은 모두 테이블 단위의 잠금이므로 테이블을 해제하지 않으면 다른 클라이언트에서 그 테이블을 사용하는 것이 불가능하다. MYSQL 에서 현재 어떤 테이블이 잠겨있는지 확인하는 방법을 알아보자</p>
<p>MYSQL에서 테이블의 잠금을 획득하는 방법은 LOCK TABLES 명령을 이용해 명시적으로 획득하는 방법과, 쿼리문을 통한 묵시적 잠금획득 방법이 있다. 명시적인 방법은 UNLOCK TABLES 명령으로 해제하기 전에는 자동으로 해제되지 않는다.</p>
<p>아무런 옵션 없이 SHOW OPEN TABLES 명령을 바로 실행하면 MYSQL 서버의 모든 테이블에 대해 잠금 여부를 보여주고, FROM DB명 을 추가하면 해당 DB에 생성된 테이블에 대해 잠금 상태를 표시한다. SHOW OPEN TABLES 명령의 결과로 출력되는 in_use 값은 해당 테이블을 잠그고 있는 클라이언트 수와 테이블의 잠금을 기다리는 클라이언트의 수까지 더해서 출력된다. 그리고 “Name_locked” 는 테이블 이름에 대한 네임 락이 걸려 있는지를 표시한다. </p>
<p>어떤 클라이언트의 커넥션이 잠금을 기다리고 있는지 보려면 SHOW PROCESSLIST 명령을 사용해야 한다. </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;4-2-Mysql-엔진의-잠금&quot;&gt;&lt;a href=&quot;#4-2-Mysql-엔진의-잠금&quot; class=&quot;headerlink&quot; title=&quot;4.2 Mysql 엔진의 잠금&quot;&gt;&lt;/a&gt;4.2 Mysql 엔진의 잠금&lt;/h2&gt;&lt;p&gt;Mysql 에서 사용되는 
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="transection" scheme="https://jumpegg.github.io/tags/transection/"/>
    
  </entry>
  
  <entry>
    <title>CH 4 트랜젝션(4.1)</title>
    <link href="https://jumpegg.github.io/2017/07/12/mysql-transection1/"/>
    <id>https://jumpegg.github.io/2017/07/12/mysql-transection1/</id>
    <published>2017-07-12T03:41:19.000Z</published>
    <updated>2017-07-12T05:33:51.470Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 에서 동시성에 영향을 주는 잠금(lock) 과 트랜잭션, 그리고 트랜잭션의 격리수준(isolation level) 을 살펴보겠다.</p>
<p>잠금(lock) 과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.</p>
<h2 id="4-1-트랜잭션"><a href="#4-1-트랜잭션" class="headerlink" title="4.1 트랜잭션"></a>4.1 트랜잭션</h2><h3 id="4-1-1-Mysql에서의-트랜잭션"><a href="#4-1-1-Mysql에서의-트랜잭션" class="headerlink" title="4.1.1 Mysql에서의 트랜잭션"></a>4.1.1 Mysql에서의 트랜잭션</h3><p>트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나(commit을 실행했을 때) 또는 아무것도 적용되지 않아야 (RollBack 또는 Transection Rollback 시키는 오류가 발생했을 때) 함을 보장해 주는 것이다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mysql&gt; create table tab_myisam (fdpk int not null, primary key(fdpk)) engine=MyISAM;</div><div class="line">mysql&gt; insert into tab_myisam (fdpk) values (3);</div><div class="line"></div><div class="line">mysql&gt; create table tab_innodb (fdpk int not null, primary key (fdpk)) engine=innoDB;</div><div class="line">mysql&gt; insert into tab_innodb (fdpk) values (3);</div></pre></td></tr></table></figure>
<p>위와같이 테스트 테이블을 생성 후 auto-commit 모드에서 다음 쿼리 문장을 실행해 보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mysql&gt; insert into tab_myisam (fdpk) values (1), (2), (3);</div><div class="line">mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3);</div></pre></td></tr></table></figure>
<p>두 개의 스토리지 엔진에서 결과가 어떻게 다를까? 위 쿼리 문장의 테스트 결과는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">mysql&gt; Insert into tab_myisam (fdpk) values (1), (2), (3);</div><div class="line">error 1062 ......</div><div class="line"></div><div class="line">mysql&gt; insert into tab_innodb (fdpk) values (1), (2), (3);</div><div class="line">error 1062 ...</div><div class="line"></div><div class="line">mysql&gt; select * from tab_myisam;</div><div class="line">+-------+</div><div class="line">| fdpk  |</div><div class="line">+-------+</div><div class="line">|    1  |</div><div class="line">|    2  |</div><div class="line">|    3  |</div><div class="line">+-------+</div><div class="line"></div><div class="line">mysql&gt; select * from tab_innodb;</div><div class="line">+-------+</div><div class="line">| fdpk  |</div><div class="line">+-------+</div><div class="line">|    3  |</div><div class="line">+-------+</div></pre></td></tr></table></figure>
<p>MyISAM의 경우 오류가 발생했음에도 1,2 가 들어가 있다. MyISAM 테이블에 insert 문장이 실행되면서 차례대로 1,2를 저장하고 그 다음 3을 저장하려는 순간 중복키 오류가 발생한 것이다. </p>
<p>InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만들어 둔다는 트랜잭션의 원칙대로 insert 쿼리 문장을 실행하기 전 상태로 그대로 복구했다.</p>
<p>MyISAM에서 발생하는 이런 현상을 부분 업데이트(partial update)라고 하며, 이것은 테이블 데이터의 정합성을 맞추는데 상당한 어려움을 유발시킨다.</p>
<h3 id="4-1-2-주의사항"><a href="#4-1-2-주의사항" class="headerlink" title="4.1.2 주의사항"></a>4.1.2 주의사항</h3><p>트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 이는 프로그램 코드에서 트랜잭션의 범위를 최소화 하라는 의미다. 설명을 위해 간단한 예를 들어보자</p>
<ol>
<li>처리시작<ul>
<li>=&gt; 데이터베이스 커넥션 생성</li>
<li>=&gt; 트랜잭션 시작</li>
</ul>
</li>
<li>사용자의 로그인 여부 확인</li>
<li>사용자의 글쓰기 내용의 오류 여부 확인</li>
<li>첨부로 업로드된 파일 확인 및 저장</li>
<li>사용자의 입력 내용을 DBMS에 저장</li>
<li>첨부 파일 정보를 DBMS에 저장</li>
<li>저장된 내용 또는 기타 정보를 DBMS에서 조회</li>
<li>게시물 등록에 대한 알림 메일 발송</li>
<li>알림 메일 발송 이력을 DBMS에 저장<ul>
<li>&lt;= 트랜잭션 종료 (commit)</li>
<li>&lt;= 데이터베이스 커넥션 반납</li>
</ul>
</li>
<li>처리 완료</li>
</ol>
<p>위 처리절차 중에 DBMS의 트랜잭션 처리에 좋지 않은 영향을 끼치는 부분을 나눠서 살펴보자</p>
<ul>
<li>커넥션 생성을 1과 2번 사이에 구현했는데 DB의 사용은 5~9 사이에 이루어진다. DB의 커넥션은 제한적이라 커넥션 유지 부분을 짧게 작성 할 수록 좋다.</li>
<li>8번의 메일전송이나 FTP 파일 전송작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게든 <strong>트랜잭션</strong> 내에서 제거하는 것이 좋다. 프로그램 실행 중에 메일서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생 할 것이다.</li>
<li>위의 과정 중 5,6번 작업은 반드시 하나의 트랜잭션으로 묶어야 하며, 7번작업은 저장된 데이터의 단순 확인작업이므로 트랜잭션에 포함시킬 필요 없다. 9번작업은 이전 5,6 번 작업과 성격이 다르기 때문에 같은 트랜잭션으로 묶을 필요가 없다.</li>
</ul>
<p>이러한 내용을 적용시켜 재설계 해보자</p>
<ol>
<li>처리 시작</li>
<li>사용자의 로그인 여부 확인</li>
<li>사용자의 클쓰기 내용의 오류 발생 여부 확인</li>
<li>첨부로 업로드된 파일 확인 및 저장<ul>
<li>=&gt; 데이터베이스 커넥션 생성</li>
<li>=&gt; 트랜잭션 시작</li>
</ul>
</li>
<li>사용자의 입력 내용을 DBMS에 저장</li>
<li>첨부 파일 정보를 DBMS에 저장<ul>
<li>&lt;= 트랜잭션 종료</li>
</ul>
</li>
<li>저장된 내용 또는 기타 정보를 DBMS에서 조회</li>
<li>게시물 등록에 대한 알림 메일 발송<ul>
<li>=&gt; 트랜잭션 시작</li>
</ul>
</li>
<li>알림 메일 발송 이력을 DBMS에 저장<ul>
<li>&lt;= 트랜잭션 종료</li>
<li>&lt;= 데이터베이스 커넥션 종료</li>
</ul>
</li>
<li>처리 완료</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql 에서 동시성에 영향을 주는 잠금(lock) 과 트랜잭션, 그리고 트랜잭션의 격리수준(isolation level) 을 살펴보겠다.&lt;/p&gt;
&lt;p&gt;잠금(lock) 과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="transection" scheme="https://jumpegg.github.io/tags/transection/"/>
    
  </entry>
  
  <entry>
    <title>Ionic Guard 구현</title>
    <link href="https://jumpegg.github.io/2017/07/09/Ionic-nav-guard/"/>
    <id>https://jumpegg.github.io/2017/07/09/Ionic-nav-guard/</id>
    <published>2017-07-09T05:23:41.000Z</published>
    <updated>2017-07-12T08:59:34.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lifecyle-을-이용한-구현"><a href="#Lifecyle-을-이용한-구현" class="headerlink" title="Lifecyle 을 이용한 구현"></a>Lifecyle 을 이용한 구현</h2><p>Angular 에서는 route 부분에서 guard를 구현해 해당 페이지에 접근가능/불가 를 제어한다. ionic에서는 해당 기능을 lifecycle을 통해 제공하고 있다.</p>
<h3 id="ionViewCanEnter-ionViewCanLeave"><a href="#ionViewCanEnter-ionViewCanLeave" class="headerlink" title="ionViewCanEnter / ionViewCanLeave"></a>ionViewCanEnter / ionViewCanLeave</h3><p>NavController에 ionViewCanEnter 와 ionViewCanLeave 는 페이지의 접근 관련제어를 담당하고 있다.</p>
<ul>
<li>ionViewCanLeave 예제</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyClass&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl: NavController</div><div class="line">	)&#123;&#125;</div><div class="line"></div><div class="line">	pushPage()&#123;</div><div class="line">		<span class="keyword">this</span>.navCtrl.push(DetailPage);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ionViewCanLeave(): <span class="built_in">boolean</span>&#123;</div><div class="line">		<span class="keyword">if</span>(isValid(CanILeave))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ionViewCanEnter 예제</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyClass&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl: NavController</div><div class="line">	)&#123;&#125;</div><div class="line"></div><div class="line">	pushPage()&#123;</div><div class="line">		<span class="keyword">this</span>.navCtrl.push(DetailPage);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> DetailPage()&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl: NavController</div><div class="line">	)&#123;&#125;</div><div class="line"></div><div class="line">	ionViewCanEnter(): <span class="built_in">boolean</span>&#123;</div><div class="line">		<span class="keyword">if</span>(isValid(CanIEnter))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ionViewCanEnter, ionViewCanLeave 둘 다 boolean/Promise<void> 의 리턴 형태를 가지고 있으므로 형태에 맞게 사용하면 되겟다</void></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lifecyle-을-이용한-구현&quot;&gt;&lt;a href=&quot;#Lifecyle-을-이용한-구현&quot; class=&quot;headerlink&quot; title=&quot;Lifecyle 을 이용한 구현&quot;&gt;&lt;/a&gt;Lifecyle 을 이용한 구현&lt;/h2&gt;&lt;p&gt;Angular 에서
    
    </summary>
    
      <category term="ionic2" scheme="https://jumpegg.github.io/categories/ionic2/"/>
    
    
      <category term="ionic2-nav" scheme="https://jumpegg.github.io/tags/ionic2-nav/"/>
    
  </entry>
  
  <entry>
    <title>3. Mysql 아키텍처(3.7, 3.8)</title>
    <link href="https://jumpegg.github.io/2017/07/08/Mysql-architecture4/"/>
    <id>https://jumpegg.github.io/2017/07/08/Mysql-architecture4/</id>
    <published>2017-07-08T14:41:26.000Z</published>
    <updated>2017-07-12T05:45:41.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-7-전문-검색-엔진-Fulltext-search-engine"><a href="#3-7-전문-검색-엔진-Fulltext-search-engine" class="headerlink" title="3.7 전문 검색 엔진(Fulltext search engine)"></a>3.7 전문 검색 엔진(Fulltext search engine)</h1><p>최근 인터넷 서비스는 대부분 본문 검색이 기본적으로 포함되는 경우가 많은데, 이러한 요건은 전문 검색 엔진 없이는 구현하기가 쉽지 않다. 여기서는 한글을 지원하고, 어느정도 수준의 성능을 보장하고 있는 트리톤과 스핑크스라는 검색엔진을 간단하게 살펴본다.</p>
<h2 id="3-7-1-트리톤-전문-검색-엔진"><a href="#3-7-1-트리톤-전문-검색-엔진" class="headerlink" title="3.7.1 트리톤 전문 검색 엔진"></a>3.7.1 트리톤 전문 검색 엔진</h2><p>트리톤을 사용하려면 먼저 Mysql의 소스코드를 패치한 후, 다시 빌드해야 하며 그 이후에 InnoDB같이 하나의 스토리지 엔진으로 사용할 수 있다. 한, 중, 일 아시아권 언어 지원이 강점이며 또한 세나(Senna) 라이브러리를 이용한 빠른 인덱싱과 검색을 제공한다. 또한 Mysql 서버의 전문 검색엔진과 달리 N-그램 방식의 인덱싱도 사용할 수 있다는 것이 가장 큰 장점이다.</p>
<h2 id="3-7-2-mGroonga-전문-검색-엔진-플러그인"><a href="#3-7-2-mGroonga-전문-검색-엔진-플러그인" class="headerlink" title="3.7.2 mGroonga 전문 검색 엔진(플러그인)"></a>3.7.2 mGroonga 전문 검색 엔진(플러그인)</h2><p>트리톤은 Mysql 5.0.87 버전에서만 사용할 수 있다. 트리톤을 5.1, 5.5 버전에서 사용해야 한다면 트리톤의 후속작인 Groonga 라는 전문 검색 엔진을 사용해야 한다. 하지만 Groonga는 Mysql과 전혀 연관없이 독립적으로 기동하는 소프트웨어라서 Mysql에 익숙한 사용자를 위해 mGroonga 라는 플러그인을 함께 제공한다.</p>
<h2 id="3-7-3-스핑크스-전문-검색-엔진"><a href="#3-7-3-스핑크스-전문-검색-엔진" class="headerlink" title="3.7.3 스핑크스 전문 검색 엔진"></a>3.7.3 스핑크스 전문 검색 엔진</h2><p>스핑크스는 Mysql 서버와는 전혀 연관이 없이 자체적인 저장 공간을 가지고 별도의 프로세스로 작동하며, Mysql 서버를 통해 접근할 수 있는 인터페이스만 제공하는 형태의 스토리지 엔진이다.</p>
<p>N-그램방식의 인덱싱과 UTF-8 언어를 지원하는것과 분산처리 기능이 상당히 뛰어나다는 것이 장점이다.</p>
<h1 id="3-8-Mysql-로그-파일"><a href="#3-8-Mysql-로그-파일" class="headerlink" title="3.8 Mysql 로그 파일"></a>3.8 Mysql 로그 파일</h1><h2 id="3-8-1-에러-로그-파일"><a href="#3-8-1-에러-로그-파일" class="headerlink" title="3.8.1 에러 로그 파일"></a>3.8.1 에러 로그 파일</h2><p>Mysql이 실행되는 도중에 발생하는 에러나 경고 메세지가 출력되는 로그 파일이다. 에러 로그 파일의 위치는 configure 파일에 “log_error” 라는 이름의 파라미터에 정의된 경로에 있는 파일이거나, 별도로 지정되지 않은 경우에는 데이터 디렉터리에 “.err” 확장자가 붙은 파일이다. 여러가지 메시지가 다양하게 출력되지만 다음에 소개되는 메시지를 가장 자주 보게 될 것이다.</p>
<ul>
<li>Mysql 이 시작하는 과정과 관련된 정보성 및 에러 메시지</li>
<li>마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지</li>
<li>쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지</li>
<li>비정상적으로 종료된 커넥션 메시지</li>
<li>InnoDB의 모니터링 명령이나 상태 조회 명령의 결과 메시지</li>
<li>Mysql 종료 메시지</li>
</ul>
<h2 id="3-8-2-제너럴-쿼리-로그-파일"><a href="#3-8-2-제너럴-쿼리-로그-파일" class="headerlink" title="3.8.2 제너럴 쿼리 로그 파일"></a>3.8.2 제너럴 쿼리 로그 파일</h2><p>쿼리 로그파일은 configure 파일의 “general-log” 라는 이름의 파라메터에 정의된 경로에 있는 파일이고 Mysql 5.1.12 이상의 버전에서는 “general_log_file” 이라는 이름의 파라메터에 정의된 경로에 있는 파일이다.</p>
<h2 id="3-8-3-슬로우-쿼리-로그"><a href="#3-8-3-슬로우-쿼리-로그" class="headerlink" title="3.8.3 슬로우 쿼리 로그"></a>3.8.3 슬로우 쿼리 로그</h2><p>Mysql 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영중에 Mysql 서버의 전체적인 성능 저하를 검사하거나 또는 정기적인 점검을 위한 튜닝으로 나눌 수 있다. 전자의 경우에는 검토해야 할 대상 쿼리가 전부라서 모두 튜닝하면 되지만, 후자의 경우에는 어떤 쿼리가 문제의 쿼리인지 판단하기가 상당히 어렵다. 이런 경우에 서비스에서 사용되고 있는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는데 슬로우 쿼리 로그가 상당히 많은 도움이 된다.</p>
<p>슬로우 쿼리 로그 파일에는 configure 에서 정의한 시간(long_query_time) 이상의 시간이 소요된 쿼리가 모두 기록된다. 실제 소요된 시간을 기준으로 기록 여부를 판단하기 때문에 정상적으로 실행된 쿼리만 기록된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-7-전문-검색-엔진-Fulltext-search-engine&quot;&gt;&lt;a href=&quot;#3-7-전문-검색-엔진-Fulltext-search-engine&quot; class=&quot;headerlink&quot; title=&quot;3.7 전문 검색 엔진(Fulltext 
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://jumpegg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>3. Mysql 아키텍처(3.4, 3.5, 3.6)</title>
    <link href="https://jumpegg.github.io/2017/07/08/Mysql-architecture3/"/>
    <id>https://jumpegg.github.io/2017/07/08/Mysql-architecture3/</id>
    <published>2017-07-08T13:22:33.000Z</published>
    <updated>2017-07-12T05:45:37.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-4-Memory-스토리지-엔진-아키텍처"><a href="#3-4-Memory-스토리지-엔진-아키텍처" class="headerlink" title="3.4 Memory 스토리지 엔진 아키텍처"></a>3.4 Memory 스토리지 엔진 아키텍처</h1><p>Memory 스토리지 엔진은 Heap 스토리지 엔진 이라고도 하는데, 이름 그대로 데이터를 메모리에 저장하는 것이 특징이다. 데이터의 크기가 작고 아주 빠른 처리가 필요한 경우 적합한 엔진이다.</p>
<h2 id="3-4-1-주의사항"><a href="#3-4-1-주의사항" class="headerlink" title="3.4.1 주의사항"></a>3.4.1 주의사항</h2><h3 id="테이블의-최대-크기"><a href="#테이블의-최대-크기" class="headerlink" title="테이블의 최대 크기"></a>테이블의 최대 크기</h3><p>다른 스토리지 엔진을 이용한 테이블과는 달리 Memory 스토리지 엔진을 사용하는 테이블은 저장할 수 있는 데이터의 최대 용량이 정해져 있다. 최대 데이터의 크기는 max_heap_table_size 파라미터로 정의한다</p>
<h3 id="고정-길이-칼럼만-지원"><a href="#고정-길이-칼럼만-지원" class="headerlink" title="고정 길이 칼럼만 지원"></a>고정 길이 칼럼만 지원</h3><p>Memory 테이블의 모든 칼럼은 항상 고정 길이로만 생성된다. 즉 varchar(100)와 같은 타입의 칼럼을 만들어도 char(100)과 동일하게 공간이 할당된다는 의미이다. 따라서 불필요하게 너무 큰 데이터 타입을 사용하지 않는 것이 좋다.</p>
<h3 id="Blob-이나-Text와-같은-LOB-Large-Object-타입은-지원하지-않음"><a href="#Blob-이나-Text와-같은-LOB-Large-Object-타입은-지원하지-않음" class="headerlink" title="Blob 이나 Text와 같은 LOB(Large Object) 타입은 지원하지 않음"></a>Blob 이나 Text와 같은 LOB(Large Object) 타입은 지원하지 않음</h3><h3 id="Memory-테이블은-기본적으로-해시-인덱스-사용"><a href="#Memory-테이블은-기본적으로-해시-인덱스-사용" class="headerlink" title="Memory 테이블은 기본적으로 해시 인덱스 사용"></a>Memory 테이블은 기본적으로 해시 인덱스 사용</h3><p>InnoDB나 MyISAM 테이블을 생성할 때 별다른 내용을 명시하지 않으면 기본적으로 B-Tree 인덱스가 생성되지만 Memory 스토리지 엔진을 사용하면 해시 인덱스를 생성한다.</p>
<h2 id="3-4-2-용도"><a href="#3-4-2-용도" class="headerlink" title="3.4.2 용도"></a>3.4.2 용도</h2><p>Memory 스토리지는 사실 Mysql 엔진이 쿼리를 처리하는 과정에서 임시로 생성되는 임시 테이블 용도로 자주 사용된다.</p>
<h1 id="3-5-NDB-클러스터-스토리지-엔진"><a href="#3-5-NDB-클러스터-스토리지-엔진" class="headerlink" title="3.5 NDB 클러스터 스토리지 엔진"></a>3.5 NDB 클러스터 스토리지 엔진</h1><p>NDB 클러스터는 “Network DataBase” 의 줄임말로 일반적으로 NDB 라 불리운다. NDB는 데이터의 분산이나 그로인한 성능 향상 보다는 가용성에 집중된 스토리지 엔진이다. </p>
<h2 id="3-5-1-NDB-클러스터의-특성"><a href="#3-5-1-NDB-클러스터의-특성" class="headerlink" title="3.5.1 NDB 클러스터의 특성"></a>3.5.1 NDB 클러스터의 특성</h2><h3 id="무공유-클러스터링"><a href="#무공유-클러스터링" class="headerlink" title="무공유 클러스터링"></a>무공유 클러스터링</h3><p>NDB는 데이터를 저장하는 스토리지가 분산되어 관리되기 때문에 하나의 데이터 저장소가 작동을 멈추더라도 서비스에 영향을 미치지 않는다.</p>
<h3 id="메모리-기반의-스토리지-엔진"><a href="#메모리-기반의-스토리지-엔진" class="headerlink" title="메모리 기반의 스토리지 엔진"></a>메모리 기반의 스토리지 엔진</h3><p>NDB는 클러스터 노드 간의 빠른 데이터 동기화를 위해 메모리를 사용한다. NDB 클러스터는 데이터 스토리지까지 분산하기 때문에 각 노드의 물리적 메모리를 모두 합친 것이 실제 저장 가능한 최대 용량이 된다. </p>
<h3 id="자동화된-Fail-over"><a href="#자동화된-Fail-over" class="headerlink" title="자동화된 Fail-over"></a>자동화된 Fail-over</h3><p>NDB는 모든 구성 노드가 서로의 상태를 계속 체크하고 있기 때문에 특정 노드에 문제가 발생해도 다른 사용 가능한 노드가 그 역할을 이어받는 형태로 페일 오버가 가능하다.</p>
<h3 id="분산된-데이터-저장소간의-동기-방식-Sync-복제"><a href="#분산된-데이터-저장소간의-동기-방식-Sync-복제" class="headerlink" title="분산된 데이터 저장소간의 동기 방식(Sync) 복제"></a>분산된 데이터 저장소간의 동기 방식(Sync) 복제</h3><p>NDB에서 데이터 저장소는 분산되어 관리되는데, 각 데이터 저장소는 전체 데이터를 N등분해서 자신이 전담하는 파티션과 백업으로 보조 파티션을 구성한다. 각 데이터 저장소는 분산된 서로의 데이터를 동기화 해야 하는데 NDB는 비동기 방식이 아닌 동기 방식으로 서로의 데이터를 전달한다.</p>
<h3 id="온라인-스키마-변경"><a href="#온라인-스키마-변경" class="headerlink" title="온라인 스키마 변경"></a>온라인 스키마 변경</h3><p>NDB는 테이블에 칼럼이나 인덱스를 추가하면서 동시에 Insert 나 Update와 같은 DML 쿼리를 처리할 수 있다. 이를 온라인 스키마 변경이라 하는데 사용하는 방법은 Alter table 이나 Create index 명령에 Online 키워드를 사용하면 된다. Online 키워드를 사용하지 않은 스키마 변경 쿼리(DDL)은 클러스터가 온라인 처리 유무를 판단하고 가능한 경우 온라인 방식으로 처리한다.</p>
<h3 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h3><h3 id="네트워크-DB"><a href="#네트워크-DB" class="headerlink" title="네트워크 DB"></a>네트워크 DB</h3><p>NDB는 내부적으로 데이터를 저장하고 읽기 위해 네트워크를 기반으로 작동한다. 이는 하나의 서버에서 모든 처리가 일어나는 다른 스토리지 엔진과는 상당히 다른 개념이다</p>
<h2 id="3-5-2-NDB-클러스터의-아키텍처"><a href="#3-5-2-NDB-클러스터의-아키텍처" class="headerlink" title="3.5.2 NDB 클러스터의 아키텍처"></a>3.5.2 NDB 클러스터의 아키텍처</h2><h3 id="NDB-클러스터-노드의-종류"><a href="#NDB-클러스터-노드의-종류" class="headerlink" title="NDB 클러스터 노드의 종류"></a>NDB 클러스터 노드의 종류</h3><ul>
<li>관리노드</li>
</ul>
<p>관리노드는 실제 NDB가 정상 상태에서 서비스되는 도중에는 거의 하는 일이 없다. 관리노드는 NDB 클러스터의 전체적인 구조에 대한 정보를 다른 노드에게 전파하거나 각 노드의 장애 상황을 전파하는 역할을 담당한다.</p>
<ul>
<li>데이터 노드</li>
</ul>
<p>데이터 노드는 클러스터에 대한 전반적인 작업을 수행하는 노드다. 대표적으로는 데이터를 저장하는 스토리지를 관리하고 SQL 노드에서 오는 데이터 조작 요청을 모두 처리한다. 또한 SQL 노드가 아닌 API 노드의 요청도 처리한다. 기본적으로 데이터에 관련된 모든 요청을 데이터 노드가 처리한다고 이해하면 된다.</p>
<ul>
<li>SQL 노드</li>
</ul>
<p>NDB에 접속해 데이ㅓ를 읽고 쓰는 방법은 Mysql 서버를 통해 Sql 문법으로 처리할 수도 있지만 자바나 C 같은 프로그래밍 언어를 이용해 클러스터의 데이터를 조작할 수도 있다. 후자의 방법은 NDB API를 이용하는 방법으로 API 노드라고 표현한다. 반면 SQL서버를 이용해 NDB에 접속하는 경우를 SQL 노드라고 한다.</p>
<h3 id="데이터-노드-간의-파티션-관리"><a href="#데이터-노드-간의-파티션-관리" class="headerlink" title="데이터 노드 간의 파티션 관리"></a>데이터 노드 간의 파티션 관리</h3><p>NDB 클러스터는 데이터 노드가 손상되어도 서비스가 가능하도록 클러스터 데이터를 파티션해서 각 파티션을 최소 2개 이상의 데이터 노드에 복제해둔다. 또한 원활한 관리를 위해 데이터 노드를 노드 그룹으로 나누는데, 노드 그룹에는 반드시 1개 이상의 데이터 노드가 존재해야 하며, 노드 그룹에 속한 데이터 노드는 항상 동일한 데이터 파티션을 가진다.</p>
<h2 id="3-5-3-클러스터-간의-복제-구성"><a href="#3-5-3-클러스터-간의-복제-구성" class="headerlink" title="3.5.3 클러스터 간의 복제 구성"></a>3.5.3 클러스터 간의 복제 구성</h2><p>NDB 클러스터에도 Mysql의 복제를 적용할 수 있는데, 이런 경우는 특별히 클러스터간 복제라고 표현한다.</p>
<h2 id="3-5-6-NDB-클러스터의-용도"><a href="#3-5-6-NDB-클러스터의-용도" class="headerlink" title="3.5.6 NDB 클러스터의 용도"></a>3.5.6 NDB 클러스터의 용도</h2><p>처음에 NDB는 이동통신 사용자의 로그인 정보를 저장하는데 있었는데, 가용성이 극대화된, 소위 세션 데이터 전용 데이터베이스를 만드는 것이 목적이었다. 지금도 세션 전용 데이터베이스로 많이 사용되고 있다. </p>
<h1 id="3-6-TOKUDB-스토리지-엔진"><a href="#3-6-TOKUDB-스토리지-엔진" class="headerlink" title="3.6 TOKUDB 스토리지 엔진"></a>3.6 TOKUDB 스토리지 엔진</h1><h2 id="3-6-1-프랙탈-트리-Fractal-Tree-인덱스-지원"><a href="#3-6-1-프랙탈-트리-Fractal-Tree-인덱스-지원" class="headerlink" title="3.6.1 프랙탈 트리(Fractal Tree) 인덱스 지원"></a>3.6.1 프랙탈 트리(Fractal Tree) 인덱스 지원</h2><p>B-Tree의 경우 계속되는 Insert, Update, Delete 작업으로 인해 인덱스 페이지 내에 사용되지 못하는 공간이 생기는데 이를 단편화라고 한다. 단편화 현상에 의해 동일한 레코드건수를 조회 하더라도 디스크에서 읽어야 할 인덱스의 숫자가 많아질 수 있고, 버퍼 풀과 같은 캐시영역의 공간도 많이 차지하게 된다. 이러한 현상은 범위 검색과 같은 작업에 비효율성을 발생시킨다.</p>
<p>프랙탈 트리 인덱스는 B-Tree의 단점을 보완한 새로운 형태의 인덱싱 알고리즘이며, 이 알고리즘을 사용한 TokuDB는 프랙탈 트리의 알고리즘 개발자가 설립한 회사에서 출시한 스토리지 엔진이다.</p>
<h2 id="3-6-2-대용량-데이터와-빠른-Insert-처리"><a href="#3-6-2-대용량-데이터와-빠른-Insert-처리" class="headerlink" title="3.6.2 대용량 데이터와 빠른 Insert 처리"></a>3.6.2 대용량 데이터와 빠른 Insert 처리</h2><p>위와 같은 프랙탈 트리를 사용함으로써 인덱스에 새로운 레코드를 추가하는 작업이 상당히 빨라진다.</p>
<h2 id="3-6-3-트랜잭션-및-잠금-처리"><a href="#3-6-3-트랜잭션-및-잠금-처리" class="headerlink" title="3.6.3 트랜잭션 및 잠금 처리"></a>3.6.3 트랜잭션 및 잠금 처리</h2><h2 id="3-6-4-그-이외의-특징"><a href="#3-6-4-그-이외의-특징" class="headerlink" title="3.6.4 그 이외의 특징"></a>3.6.4 그 이외의 특징</h2><h2 id="3-6-5-TokuDB의-주-용도"><a href="#3-6-5-TokuDB의-주-용도" class="headerlink" title="3.6.5 TokuDB의 주 용도"></a>3.6.5 TokuDB의 주 용도</h2><ul>
<li>SNS 기반의 대용량 테이블(동시성을 크게 요하지 않는)</li>
<li>실시간 웹페이지 클릭 분석</li>
<li>웹 서버나 게임 서버의 로그 분석</li>
<li>고성능 웹 크롤링</li>
<li>데이터웨어 하우스</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-4-Memory-스토리지-엔진-아키텍처&quot;&gt;&lt;a href=&quot;#3-4-Memory-스토리지-엔진-아키텍처&quot; class=&quot;headerlink&quot; title=&quot;3.4 Memory 스토리지 엔진 아키텍처&quot;&gt;&lt;/a&gt;3.4 Memory 스토리지 엔
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://jumpegg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>3. Mysql 아키텍처(3.2, 3.3)</title>
    <link href="https://jumpegg.github.io/2017/07/08/Mysql-architecture2/"/>
    <id>https://jumpegg.github.io/2017/07/08/Mysql-architecture2/</id>
    <published>2017-07-08T09:02:39.000Z</published>
    <updated>2017-07-12T05:45:37.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-2-InnoDB-스토리지-엔진-아키텍처"><a href="#3-2-InnoDB-스토리지-엔진-아키텍처" class="headerlink" title="3.2 InnoDB 스토리지 엔진 아키텍처"></a>3.2 InnoDB 스토리지 엔진 아키텍처</h1><h2 id="3-2-1-InnoDB-스토리지-엔진의-특성"><a href="#3-2-1-InnoDB-스토리지-엔진의-특성" class="headerlink" title="3.2.1 InnoDB 스토리지 엔진의 특성"></a>3.2.1 InnoDB 스토리지 엔진의 특성</h2><h3 id="PK에-의한-클러스터링"><a href="#PK에-의한-클러스터링" class="headerlink" title="PK에 의한 클러스터링"></a>PK에 의한 클러스터링</h3><p>InnoDB의 모든 데이터 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉 PK값의 순서대로 디스크에 저장된다는 의미이며, 이로 인해 PK에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다.</p>
<h3 id="잠금이-필요없는-일관된-읽기"><a href="#잠금이-필요없는-일관된-읽기" class="headerlink" title="잠금이 필요없는 일관된 읽기"></a>잠금이 필요없는 일관된 읽기</h3><p>InnoDB는 MVCC(Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다.</p>
<h3 id="외래-키-지원"><a href="#외래-키-지원" class="headerlink" title="외래 키 지원"></a>외래 키 지원</h3><p>InnoDB에서는 외래키를 지원하지만 실무에서는 여러가지 제약때문에 잘 사용하지 않다. 하지만 데이터베이스의 좋은 가이드 역할로 사용이 가능하다.</p>
<h3 id="자동-데드락-감지"><a href="#자동-데드락-감지" class="headerlink" title="자동 데드락 감지"></a>자동 데드락 감지</h3><p>InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고, 감지된 데드락은 관련 트랜잭션 중에서 rollback 이 가장 용이한 트랜잭션을 자동적으로 강제 종료해 버린다.</p>
<h3 id="자동화된-장애-복구"><a href="#자동화된-장애-복구" class="headerlink" title="자동화된 장애 복구"></a>자동화된 장애 복구</h3><h3 id="오라클의-아키텍처-적용"><a href="#오라클의-아키텍처-적용" class="headerlink" title="오라클의 아키텍처 적용"></a>오라클의 아키텍처 적용</h3><h2 id="3-2-2-InnoDB-버퍼-풀"><a href="#3-2-2-InnoDB-버퍼-풀" class="headerlink" title="3.2.2 InnoDB 버퍼 풀"></a>3.2.2 InnoDB 버퍼 풀</h2><p>InnoDB 스토리지 엔젠에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. MyISAM 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 InnoDB의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리하고 있는 것이다.</p>
<h2 id="3-2-3-Undo-로그"><a href="#3-2-3-Undo-로그" class="headerlink" title="3.2.3 Undo 로그"></a>3.2.3 Undo 로그</h2><p>언두 영역은 update, delete와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.</p>
<p>언두의 데이터는 크게 두가지 용도로 사용되는데, 첫 번째가 트랜잭션의 롤백 대비용, 두 번째는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 사용된다. 트랜잭션의 격리 수준이라는 개념이 있는데, 이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때, 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준이다.</p>
<h2 id="3-2-4-Insert-Buffer"><a href="#3-2-4-Insert-Buffer" class="headerlink" title="3.2.4 Insert Buffer"></a>3.2.4 Insert Buffer</h2><p>RDBMS에서 레코드가 insert 되거나 update 될때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다. 그런 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다. InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않고 디스크로 부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 인서트 버퍼(Insert Buffer) 라고 한다.</p>
<h2 id="3-2-5-Redo-로그-및-로그-버퍼"><a href="#3-2-5-Redo-로그-및-로그-버퍼" class="headerlink" title="3.2.5 Redo 로그 및 로그 버퍼"></a>3.2.5 Redo 로그 및 로그 버퍼</h2><p>쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다. 하지만 이런 작업은 랜덤하게 디스크에 기록해야 하므로 디스크를 바쁘게 만드는 작업이다. 그래서 대부분의 DBMS에는 변경된 데이터를 버퍼링해 두기 위해 InnoDB 버퍼 풀과 같은 장치가 포함되어 있다. 하지만 이 장치만으로는 ACID를 보장할 수 없는데 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 이를 <strong>리두 로그</strong> 라고 한다.</p>
<p>하지만 사용량이 많은 DBMS 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가 되는데, 이러한 부분을 보완하기 위한 로그 버퍼링이 존재하는데 이 로그 버퍼링에 사용되는 공간이 <strong>로그 버퍼</strong> 이다.</p>
<h2 id="3-2-6-MVCC-Multi-Version-Concurrency-Control"><a href="#3-2-6-MVCC-Multi-Version-Concurrency-Control" class="headerlink" title="3.2.6 MVCC(Multi Version Concurrency Control)"></a>3.2.6 MVCC(Multi Version Concurrency Control)</h2><p>MVCC는 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB에서는 언두 로그를 이용해 이 기능을 구현한다. </p>
<p>update 문장이 실행될 때 기존의 데이터는 언두 로그에 기록되며 새로운 데이터는 InnoDB 버퍼 풀에 기록된다. 즉 하나의 레코드에 대해 두가지 버전의 데이터가 있으며 select문을 이용해 조회를 할 경우 보여지는 데이터는 격리수준에 따라 다르다. </p>
<p>최종적으로 commit 이 되면 레코드의 테이터를 바꾸고, rollback 을 하면 언두 영역에 있는 데이터를 버퍼 풀로 가져온다. 즉 커밋이 된다고 언두 영역의 데이터가 바로 삭제되는게 아니다. 이 언두 영역을 필요로 하는 트랜잭션이 더는 필요 없을 때 비로소 삭제된다.</p>
<h2 id="3-2-7-잠금이-없는-일관된-읽기"><a href="#3-2-7-잠금이-없는-일관된-읽기" class="headerlink" title="3.2.7 잠금이 없는 일관된 읽기"></a>3.2.7 잠금이 없는 일관된 읽기</h2><p>특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 select 작업을 방해하지 않는다. 이를 잠금이 없는 일관된 읽기 라고 표현하며 InnoDB에서는 언두 로그를 사용하여 구현한다.</p>
<h1 id="3-3-MyISAM-스토리지-엔진-아키텍처"><a href="#3-3-MyISAM-스토리지-엔진-아키텍처" class="headerlink" title="3.3 MyISAM 스토리지 엔진 아키텍처"></a>3.3 MyISAM 스토리지 엔진 아키텍처</h1><h2 id="3-3-1-키-캐시"><a href="#3-3-1-키-캐시" class="headerlink" title="3.3.1 키 캐시"></a>3.3.1 키 캐시</h2><p>InnoDB의 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 키 캐시다. 하지만 키 캐시는 인덱스만 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.</p>
<h2 id="3-3-2-운영체제의-캐시-및-버퍼"><a href="#3-3-2-운영체제의-캐시-및-버퍼" class="headerlink" title="3.3.2 운영체제의 캐시 및 버퍼"></a>3.3.2 운영체제의 캐시 및 버퍼</h2><p>MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다. 하지만 MyISAM 테이블의 데이터는 디스크로부터의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 그래서 운영체제의 디스크 읽기/쓰기 작업으로 요청될 수 밖에 없다. 운영체제의 캐시 기능은 InnoDB 같이 데이터의 특성을 알고 전문적으로 캐시나 버퍼링을 하지는 못하지만 그래도 없는 것 보다는 낫다. 운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-2-InnoDB-스토리지-엔진-아키텍처&quot;&gt;&lt;a href=&quot;#3-2-InnoDB-스토리지-엔진-아키텍처&quot; class=&quot;headerlink&quot; title=&quot;3.2 InnoDB 스토리지 엔진 아키텍처&quot;&gt;&lt;/a&gt;3.2 InnoDB 스토리지 엔
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://jumpegg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>3. Mysql 아키텍쳐(3.1)</title>
    <link href="https://jumpegg.github.io/2017/07/08/Mysql-architecture/"/>
    <id>https://jumpegg.github.io/2017/07/08/Mysql-architecture/</id>
    <published>2017-07-08T07:37:31.000Z</published>
    <updated>2017-07-12T05:37:35.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-1-Mysql-전체적인-구조"><a href="#3-1-1-Mysql-전체적인-구조" class="headerlink" title="3.1.1 Mysql 전체적인 구조"></a>3.1.1 Mysql 전체적인 구조</h2><p>Mysql 은 크게 Mysql엔진과 스토리지 엔진으로 구분해 볼 수 있다.</p>
<h3 id="Mysql-엔진"><a href="#Mysql-엔진" class="headerlink" title="Mysql 엔진"></a>Mysql 엔진</h3><p>Mysql 엔진은 클라이언트로 부터 접속 및 쿼리 요청을 처리하는 <strong>커넥션 핸들러</strong> 와 <strong>SQL 파서</strong> 및 <strong>전처리기</strong>, 그리고 쿼리의 최적화된 실행을 위한 <strong>옵티마이저</strong> 가 중심을 이룬다. 그리고 성능 향상을 위해 MyISAM의 키 캐시나 InnoDB의 버퍼 풀과 같은 보조 저장소 기능이 포함되 있다.</p>
<h3 id="스토리지-엔진"><a href="#스토리지-엔진" class="headerlink" title="스토리지 엔진"></a>스토리지 엔진</h3><p>스토리지 엔진은 실질적으로 데이터를 디스크 스토리지에 저장하거나 디스크로 부터 데이터를 읽어오는 부분을 전담한다. Mysql 서버에서 Mysql엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.</p>
<h3 id="핸들러-API"><a href="#핸들러-API" class="headerlink" title="핸들러 API"></a>핸들러 API</h3><p>Mysql 엔진의 쿼리 실행기에서 데이터를 읽기/쓰기 작업을 할때 스토리지에 읽기/쓰기 작업을 요청하는데, 이런 요청작업을 핸들러(Handler) 요청이라 하고, 여기에 사용되는 API를 핸들러API라고 한다.</p>
<h2 id="3-1-2-Mysql-스레딩-구조"><a href="#3-1-2-Mysql-스레딩-구조" class="headerlink" title="3.1.2 Mysql 스레딩 구조"></a>3.1.2 Mysql 스레딩 구조</h2><p>Mysql은 프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 포그라운드(Foreground)와 백그라운드(Background)로 구분할 수 있다.</p>
<h3 id="포그라운드-스레드"><a href="#포그라운드-스레드" class="headerlink" title="포그라운드 스레드"></a>포그라운드 스레드</h3><p>포그라운드 스레드는 최소한 Mysql 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.</p>
<p>포그라운드 스레드는 데이터를 Mysql의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다. MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리한다.</p>
<h3 id="백그라운드-스레드"><a href="#백그라운드-스레드" class="headerlink" title="백그라운드 스레드"></a>백그라운드 스레드</h3><p>MyISAM과는 다르게 InnoDB에서는 여러가지 작업이 백그라운드로 처리된다. 그중 가장 중요한것이 <strong>로그 스레드(Log thread)</strong> 와 버퍼의 데이터를 디스크로 내려 쓰는 작업을 처리하는 <strong>쓰기 스레드(Write thread)</strong> 이다.</p>
<h2 id="3-1-3-메모리-할당-구조"><a href="#3-1-3-메모리-할당-구조" class="headerlink" title="3.1.3 메모리 할당 구조"></a>3.1.3 메모리 할당 구조</h2><p>Mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.<br>두 영역의 차이는 Mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지로 구분할 수 있다.</p>
<h3 id="글로벌-메모리-영역"><a href="#글로벌-메모리-영역" class="headerlink" title="글로벌 메모리 영역"></a>글로벌 메모리 영역</h3><p>일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.</p>
<h3 id="로컬-메모리-영역"><a href="#로컬-메모리-영역" class="headerlink" title="로컬 메모리 영역"></a>로컬 메모리 영역</h3><p>세션 메모리 영역이라고도 표현하며, 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 로컬메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.</p>
<h2 id="3-1-4-플러그인-스토리지-엔진-모델"><a href="#3-1-4-플러그인-스토리지-엔진-모델" class="headerlink" title="3.1.4 플러그인 스토리지 엔진 모델"></a>3.1.4 플러그인 스토리지 엔진 모델</h2><p>Mysql의 독특한 구조 중 대표적인 것이 바로 플러그인 모델이다. 쿼리 실행과정에서 데이터 읽기/쓰기 작업이 스토리지 엔진에 의해 처리된다. 복잡한 처리, 예를 들면 group by 나 order by 는 Mysql 의 쿼리 실행기에서 처리가 된다. 여기서 중요한점은 <strong>‘하나의 쿼리 작업’</strong> 은 <strong>‘여러가지 하위 작업’</strong> 으로 나뉘는데 각각의 하위 작업이 <strong>어디에서</strong> 처리되는지 구분할 줄 알아야 한다.<br>스토리지 엔진은 대표적으로 MyISAM과 InnoDB가 있다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show engines; -- 이 명령어를 통해 지원되는 엔진 확인가능</div><div class="line">...</div><div class="line">mysql&gt; show plugins; -- 플러그인 확인 명령어</div></pre></td></tr></table></figure>
<h2 id="3-1-5-쿼리-실행구조"><a href="#3-1-5-쿼리-실행구조" class="headerlink" title="3.1.5 쿼리 실행구조"></a>3.1.5 쿼리 실행구조</h2><h3 id="파서"><a href="#파서" class="headerlink" title="파서"></a>파서</h3><p>파서는 쿼리문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다.</p>
<h3 id="전처리기"><a href="#전처리기" class="headerlink" title="전처리기"></a>전처리기</h3><p>파서에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.</p>
<h3 id="옵티마이저"><a href="#옵티마이저" class="headerlink" title="옵티마이저"></a>옵티마이저</h3><p>쿼리문장을 저렴한 비용으로 가장 빠르게 처리할 지 결정하는 역할을 담당한다.</p>
<h3 id="실행-엔진"><a href="#실행-엔진" class="headerlink" title="실행 엔진"></a>실행 엔진</h3><p>만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.</p>
<h3 id="핸들러-스토리지-엔진"><a href="#핸들러-스토리지-엔진" class="headerlink" title="핸들러(스토리지 엔진)"></a>핸들러(스토리지 엔진)</h3><p>Mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.</p>
<h2 id="3-1-6-복제-Replication"><a href="#3-1-6-복제-Replication" class="headerlink" title="3.1.6 복제(Replication)"></a>3.1.6 복제(Replication)</h2><p>데이터가 갈수록 대용량화돼 가는 것을 생각하면 확장성(Scalability)은 DBMS에서 아주 중요한 요소인데, Mysql에서 확장성을 위한 일반적인 기술로는 복제(Replication)를 들어볼 수 있다.</p>
<p>복제는 2대 이상의 Mysql 서버가 동일한 데이터를 담도록 실시간 동기화하는 기술이다. 서버의 역할에 따라서 master 와 slave 로 나눌 수 있다.</p>
<h3 id="복제-주의사항"><a href="#복제-주의사항" class="headerlink" title="복제 주의사항"></a>복제 주의사항</h3><ul>
<li>슬레이브는 하나의 마스터만 설정 가능</li>
<li>마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 일기 전용으로 설정</li>
<li>슬레이브 서버용 장비는 마스터와 동일한 사양이 적합</li>
<li>복제가 불필요한 경우에는 바이너리 로그 중지</li>
<li>바이너리 로그와 트랜잭션 격리 수준(Isolation level)</li>
</ul>
<h2 id="3-1-7-쿼리-캐시"><a href="#3-1-7-쿼리-캐시" class="headerlink" title="3.1.7 쿼리 캐시"></a>3.1.7 쿼리 캐시</h2><p>쿼리 캐시는 타 DBMS에는 없는 Mysql의 독특한 기능이다. </p>
<p>여러가지 복잡한 처리 절차와 꽤 큰 비용을 들여 실행된 결과를 쿼리 캐시에 담아 두고, 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾아 바로 결과를 준다.</p>
<p>쿼리 캐시는 SQL 문장의 결과는 메모리에 캐시해 두는 기능이다. 쿼리 캐시의 구조는 간단한 키와 값의 쌍으로 관리되는 맵(Map)과 같은 데이터 구조로 구현되 있다. 여기서 키는 <strong>쿼리문장</strong> , 값은 <strong>쿼리 실행결과</strong> 형태로 저장되어 있다.</p>
<p>쿼리 캐시를 사용할 경우 캐시에 있는 쿼리 결과를 넘기기 전에 다음과 같은 확인절차가 필요하다.</p>
<ol>
<li>요청된 쿼리 문장이 쿼리 캐시에 존재하는가?</li>
<li>해당 사용자가 그 결과를 볼 수 있는 권한을 가지는가?</li>
<li>트랜젝션 내에서 실행된 쿼리인 경우, 그 결과가 가시범위 내의 트랜젝션에서 만들어진 결과인가?</li>
<li>쿼리에 사용된 기능이 캐시되도 동일한 결과를 보장할 수 있는가?<ul>
<li>Current_date, sysdate, rand 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가?</li>
<li>프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?</li>
</ul>
</li>
<li>캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?</li>
<li>쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?</li>
<li>그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?</li>
</ol>
<p>이런 제약사항들에도 불구하고 쿼리캐시는 훌륭한 기능이다. 다음을 통해 쿼리캐시 관련 데이터들을 볼 수 있다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show global status like 'Qcache%'; -- 쿼리캐시 관련 데이터</div><div class="line">....</div><div class="line">mysql&gt; show global status like 'Com_select';</div></pre></td></tr></table></figure>
<p>Qcache_hits는 쿼리캐시로 처리된 select 쿼리의 수를 의미하며, Com_select 쿼리캐시에서 결과를 찾지 못해서 직접 실행한 횟수이다. 즉 Com_select 와 Qcache_hits를 더하면 Mysql 서버로 요청된 모든 select 문장의 총 합이 되는 것이다.</p>
<blockquote>
<p>쿼리 캐시 히트율(%) = Qcache_hits/ (Qcache_hits + Com_select) * 100</p>
</blockquote>
<p>보통 쿼리캐시 히트율이 20% 이상이면 쿼리캐시를 사용하는 것이 좋다고 한다. 하지만 히트율이 1% 라도 아주 큰 자원을 소모하는 쿼리의 경우 쿼리캐시를 사용하는 것이 좋다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-1-1-Mysql-전체적인-구조&quot;&gt;&lt;a href=&quot;#3-1-1-Mysql-전체적인-구조&quot; class=&quot;headerlink&quot; title=&quot;3.1.1 Mysql 전체적인 구조&quot;&gt;&lt;/a&gt;3.1.1 Mysql 전체적인 구조&lt;/h2&gt;&lt;p&gt;My
    
    </summary>
    
      <category term="Mysql" scheme="https://jumpegg.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://jumpegg.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Ionic 간단한 nav 개념잡기</title>
    <link href="https://jumpegg.github.io/2017/07/07/ionic-nav/"/>
    <id>https://jumpegg.github.io/2017/07/07/ionic-nav/</id>
    <published>2017-07-07T14:37:10.000Z</published>
    <updated>2017-07-12T08:59:28.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IONIC-간단한-nav-개념잡기"><a href="#IONIC-간단한-nav-개념잡기" class="headerlink" title="IONIC 간단한 nav 개념잡기"></a>IONIC 간단한 nav 개념잡기</h2><h3 id="기본적인-페이지-이동"><a href="#기본적인-페이지-이동" class="headerlink" title="기본적인 페이지 이동"></a>기본적인 페이지 이동</h3><p>ionic 은 router 의 개념이 stack을 통해 view 를 push/pop 하는 형식이다.(이것은 한글인가 영어인가….)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavController&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">.....</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	templateUrl: <span class="string">'yourIndex.html'</span>;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> IndexPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl:NavController)&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>여기서 클래스 이름 그대로 NavController 가 네비게이션 컨트롤러 역할을 한다. 페이지를 넘기고 싶다면 push 를 이용해서 이동하고 싶은 페이지의 컴포넌트를 입력시키면 된다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavController&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">.....</div><div class="line"><span class="keyword">import</span> &#123;SecondPage&#125; <span class="keyword">from</span> <span class="string">'../Component/SecondPage/SecondPage'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	templateUrl: <span class="string">'yourIndex.html'</span>;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> IndexPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl:NavController)&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	moveToSecond()&#123;</div><div class="line">		<span class="keyword">this</span>.navCtrl.push(SecondPage); <span class="comment">//push 를 이용한 페이지 이동</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="페이지간-데이터-전송"><a href="#페이지간-데이터-전송" class="headerlink" title="페이지간 데이터 전송"></a>페이지간 데이터 전송</h3><p>페이지간 데이터를 전송하고 싶다면 push에 파라메터로 넘기고싶은 데이터의 Object를 파라메터로 넘겨주고, 받는 페이지에서는 navParams.get() 을 이용해서 받으면 된다.</p>
<ul>
<li>파라메터를 넘기는 IndexPage</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavController&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">.....</div><div class="line"><span class="keyword">import</span> &#123;SecondPage&#125; <span class="keyword">from</span> <span class="string">'../Component/SecondPage/SecondPage'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	templateUrl: <span class="string">'yourIndex.html'</span>;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> IndexPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl:NavController)&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	moveToSecond()&#123;</div><div class="line">		<span class="keyword">this</span>.navCtrl.push(SecondPage,&#123;msg: <span class="string">"It's work!!"</span>&#125;); <span class="comment">// 컴포넌트에 msg 라는 파라메터 넘김</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>파라메터를 받는 SecondPage</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavController, NavParams&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">....</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	templateUrl: <span class="string">'yourSecond.html'</span>;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> SecondPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl:NavController, </div><div class="line">		<span class="keyword">public</span> navParams:NavParams)&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ionViewDidLoad() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.navParams.get(<span class="string">'msg'</span>)); <span class="comment">// 파라메터에 접근</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rootPage-설정"><a href="#rootPage-설정" class="headerlink" title="rootPage 설정"></a>rootPage 설정</h3><p>페이지가 이동을 하면 새로 root 페이지를 설정해줘야 할 때가 있다. 예를들면 로그인 이후 화면? 같은것을 예로 들 수 있다. setRoot()를 이용하면 root 페이지를 바꿀 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;NavController, NavParams&#125; <span class="keyword">from</span> <span class="string">'ionic-angular'</span>;</div><div class="line">....</div><div class="line"></div><div class="line"><span class="meta">@Component</span>(&#123;</div><div class="line">	templateUrl: <span class="string">'yourSecond.html'</span>;</div><div class="line">&#125;)</div><div class="line"><span class="keyword">export</span> <span class="keyword">class</span> SecondPage&#123;</div><div class="line">	<span class="keyword">constructor</span>(<span class="params"></span></div><div class="line">		<span class="keyword">public</span> navCtrl:NavController, </div><div class="line">		<span class="keyword">public</span> navParams:NavParams)&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ionViewDidLoad() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.navParams.get(<span class="string">'msg'</span>)); <span class="comment">// 파라메터에 접근</span></div><div class="line">		<span class="keyword">this</span>.navCtrl.setRoot(SecondPage); <span class="comment">// SecondPage로 root를 바꾼다</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setRoot() 사용시 주의점은 root를 바꿔주면서 해당 페이지로 이동시키기 때문에 setRoot() 를 사용하는 지점을 잘 생각해야 한다. 실수로 자기 자신을 루트로 잡아봤는데 무한루프가 도는 것을 볼 수 있었다.</p>
<p><strong>참조 사이트</strong><br><a href="http://www.joshmorony.com/a-simple-guide-to-navigation-in-ionic-2/" target="_blank" rel="external">http://www.joshmorony.com/a-simple-guide-to-navigation-in-ionic-2/</a><br><a href="http://samse.tistory.com/446" target="_blank" rel="external">고 투 더 멘토</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IONIC-간단한-nav-개념잡기&quot;&gt;&lt;a href=&quot;#IONIC-간단한-nav-개념잡기&quot; class=&quot;headerlink&quot; title=&quot;IONIC 간단한 nav 개념잡기&quot;&gt;&lt;/a&gt;IONIC 간단한 nav 개념잡기&lt;/h2&gt;&lt;h3 id=&quot;기
    
    </summary>
    
      <category term="ionic2" scheme="https://jumpegg.github.io/categories/ionic2/"/>
    
    
      <category term="ionic2-nav" scheme="https://jumpegg.github.io/tags/ionic2-nav/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 를 시작해보자</title>
    <link href="https://jumpegg.github.io/2017/07/06/start/"/>
    <id>https://jumpegg.github.io/2017/07/06/start/</id>
    <published>2017-07-06T09:15:19.000Z</published>
    <updated>2017-07-06T09:31:29.888Z</updated>
    
    <content type="html"><![CDATA[<p>hexo 가 있는건 진작 알고 있었는데, 혼자 하는 프로젝트가 어느정도 끝나가면서 사용했던 개념들을 기록 할 공간이 필요했다. 그래서 이번에 기록 할 겸 hexo도 사용해볼겸 해서 블로그를 시작하게 되었다.</p>
<p>우선 hexo 를 시작해보자</p>
<h2 id="Hexo-를-시작해보자"><a href="#Hexo-를-시작해보자" class="headerlink" title="Hexo 를 시작해보자"></a>Hexo 를 시작해보자</h2><h3 id="hexo-설치"><a href="#hexo-설치" class="headerlink" title="hexo 설치"></a>hexo 설치</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>cli 환경이 익숙치 않은 사람들에게는 낯설겠지만 hexo 는 cli 환경에서 페이지를 생성하고 markdown 문법을 사용해서 내용을 구성한다.</p>
<p>아무튼, 명령어를 치면 이제 hexo 명령어 들을 사용할 수 있다.</p>
<h3 id="hexo-init"><a href="#hexo-init" class="headerlink" title="hexo init"></a>hexo init</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init [폴더명]</div></pre></td></tr></table></figure>
<p>init 명령어를 사용하면 해당 폴더에 hexo를 사용하기 위한 기본 구조와 파일들이 생성된다 이제 생성한 폴더에 들어가서 hexo 명령어들을 이용해서 작업하면 된다.</p>
<h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [포스트명]</div></pre></td></tr></table></figure>
<p>폴더 안으로 들어가서 new 명령어를 실행하면 [포스트명] 으로 source/_posts/ 폴더안에 파일이 생성된다. 이 파일들이 우리가 만드는 컨텐츠가 된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo 가 있는건 진작 알고 있었는데, 혼자 하는 프로젝트가 어느정도 끝나가면서 사용했던 개념들을 기록 할 공간이 필요했다. 그래서 이번에 기록 할 겸 hexo도 사용해볼겸 해서 블로그를 시작하게 되었다.&lt;/p&gt;
&lt;p&gt;우선 hexo 를 시작해보
    
    </summary>
    
      <category term="Hexo" scheme="https://jumpegg.github.io/categories/Hexo/"/>
    
    
  </entry>
  
</feed>
